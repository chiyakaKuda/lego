<?xml version="1.0"?>
<doc>
    <assembly>
        <name>Microsoft.VisualStudio.CoreUtility</name>
    </assembly>
    <members>
        <member name="T:Microsoft.VisualStudio.Utilities.AppliesToProjectAttribute">
            <summary>
            Adds AppliesTo metadata to a MEF export to indicate where this export should be applied.
            </summary>
        </member>
        <member name="M:Microsoft.VisualStudio.Utilities.AppliesToProjectAttribute.#ctor(System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:Microsoft.VisualStudio.Utilities.AppliesToProjectAttribute" /> class.
            </summary>
            <param name="appliesToExpression">
                An expression that indicates where this export should be applied.
                For example
                To declare an expression that supports (VisualC or Csharp)  AND (MSTest or Nunit) use the following syntax:
                     (VisualC | CSharp) + (MSTest | NUnit)
                
                See the following URLs for expression syntax and supported operations
               https://msdn.microsoft.com/en-us/library/microsoft.visualstudio.shell.interop.ivsbooleansymbolexpressionevaluator.evaluateexpression.aspx
               https://github.com/Microsoft/VSProjectSystem/blob/master/doc/overview/about_project_capabilities.md
            </param>
        </member>
        <member name="P:Microsoft.VisualStudio.Utilities.AppliesToProjectAttribute.AppliesTo">
            <summary>
            Gets the expression that indicates where this export should be applied.
            </summary>
        </member>
        <member name="T:Microsoft.VisualStudio.Utilities.BaseDefinitionAttribute">
            <summary>
            Represents a base definition of the current definition.
            </summary>
        </member>
        <member name="M:Microsoft.VisualStudio.Utilities.BaseDefinitionAttribute.#ctor(System.String)">
            <summary>
            Initializes a new instance of <see cref="T:Microsoft.VisualStudio.Utilities.BaseDefinitionAttribute" />.
            </summary>
            <param name="name">The base definition name. Definition names are case-insensitive.</param>
            <exception cref="T:System.ArgumentNullException"><paramref name="name" />is null or an empty string.</exception>
        </member>
        <member name="P:Microsoft.VisualStudio.Utilities.BaseDefinitionAttribute.BaseDefinition">
            <summary>
            Gets the base definition name.
            </summary>
        </member>
        <member name="T:Microsoft.VisualStudio.Utilities.BaseProxyService`1">
            <summary>
            A proxy service for exposing best implementation to the MEF composition.
            </summary>
        </member>
        <member name="T:Microsoft.VisualStudio.Utilities.BaseUtility.DefaultEditorOptionValueAttribute">
            <summary>
            Attribute to define a default value for an editor option. Only value types and strings are supported.
            </summary>
        </member>
        <member name="M:Microsoft.VisualStudio.Utilities.BaseUtility.DefaultEditorOptionValueAttribute.#ctor(System.Object)">
            <summary>
            Attribute to define the default value of an editor option. 
            </summary>
            <param name="defaultEditorOptionValue">The default value that editor option should have before being set by a component. Should be of the same type of the editor option. Only value types and strings are supported</param>
            <exception cref="T:System.ArgumentNullException"><paramref name="defaultEditorOptionValue" /> is null.</exception>
        </member>
        <member name="P:Microsoft.VisualStudio.Utilities.BaseUtility.DefaultEditorOptionValueAttribute.DefaultEditorOptionValue">
            <summary>
            Default Value of the editor option
            </summary>
        </member>
        <member name="T:Microsoft.VisualStudio.Utilities.DefaultOrderings">
            <summary>
            Static class defining some default placeholders for the ordering attributes.
            </summary>
            <remarks>
            <para>
            Orderable items that do not explicitly indicate they are before <see cref="F:Microsoft.VisualStudio.Utilities.DefaultOrderings.Lowest" /> have an implicit constraint
            that they are after <see cref="F:Microsoft.VisualStudio.Utilities.DefaultOrderings.Lowest" />.
            </para>
            <para>
            Orderable items that do not explicitly indicate they are after <see cref="F:Microsoft.VisualStudio.Utilities.DefaultOrderings.Highest" /> have an implicit constraint
            that they are before <see cref="F:Microsoft.VisualStudio.Utilities.DefaultOrderings.Highest" />.
            </para>
            </remarks>
        </member>
        <member name="T:Microsoft.VisualStudio.Utilities.DisplayNameAttribute">
            <summary>
            Provides a display name for an editor component part.
            </summary>    
            <remarks>
            This attribute should be localized wherever it is used.
            </remarks>
        </member>
        <member name="M:Microsoft.VisualStudio.Utilities.DisplayNameAttribute.#ctor(System.String)">
            <summary>
            Initializes a new instance of <see cref="T:Microsoft.VisualStudio.Utilities.DisplayNameAttribute" />.
            </summary>
            <param name="displayName">The display name of an editor component part.</param>
        </member>
        <member name="P:Microsoft.VisualStudio.Utilities.DisplayNameAttribute.DisplayName">
            <summary>
            Gets the display name of an editor component part.
            </summary>
        </member>
        <member name="T:Microsoft.VisualStudio.Utilities.DynamicVisibilityAttribute">
            <summary>
            A MEF attribute indicating an attributed object supports dynamic visibility.
            </summary>
        </member>
        <member name="T:Microsoft.VisualStudio.Utilities.ExportImplementationAttribute">
             <summary>
             Along with <see cref="T:Microsoft.VisualStudio.Utilities.ImportImplementationsAttribute" /> enables MEF proxy pattern where a single component export serves
             as a proxy for the best implementation selected at run time. This pattern allows component consumers to just [Import] it,
             hiding the complexity of selecting one of implementations.
             </summary>
             <example>
             A typical sample:
            
             A component contract definition:
             
             <code>
             interface IService {
                 void Foo();
             }
             </code>
            
             Default implementation:
             
             <code>
             [ExportImplementation(typeof(IService))]
             [Name("default")]
             class DefaultService : IService {...}
             </code>
            
             Another implementation:
             
             <code>
             [ExportImplementation(typeof(IService))]
             [Name("A better implementation")]
             [Order(Before = "default")]
             class AdvancedService : IService {...}
             </code>
            
             A proxy:
            
             <code>
             [Export(typeof(IService))]
             class ProxyService : IService {
                [ImportImplementations(typeof(IService))]
                IEnumerable&lt;Lazy&lt;IService, IOrderable&gt;&gt; _unorderedImplementations;
                
                public void Foo() {
                    Orderer.Order(_unorderedImplementations).FirstOrDefault()?.Value.Foo();
                }
             }
             </code>
            
             Consuming IService:
             <code>
             [Import]
             IService service = null;
             </code>
             </example>
        </member>
        <member name="M:Microsoft.VisualStudio.Utilities.ExportImplementationAttribute.#ctor(System.Type)">
            <summary>
            Creates new <see cref="T:Microsoft.VisualStudio.Utilities.ExportImplementationAttribute" /> instance.
            </summary>
            <param name="contractType">A contract type.</param>
        </member>
        <member name="T:Microsoft.VisualStudio.Utilities.IDecorated">
            <summary>
            Represents an object that provides a localized description text and an icon.
            </summary>
        </member>
        <member name="P:Microsoft.VisualStudio.Utilities.IDecorated.Icon">
            <summary>
            Gets the icon representing this object.
            </summary>
        </member>
        <member name="P:Microsoft.VisualStudio.Utilities.IDecorated.DescriptionText">
            <summary>
            Gets the localized description of this object.
            While <see cref="P:Microsoft.VisualStudio.Utilities.INamed.DisplayName" /> is the primary representation of this object,
            the description is not immediately visible and may conveys more detail.
            </summary>
        </member>
        <member name="T:Microsoft.VisualStudio.Utilities.IFeatureFlagsAdapter">
            <summary>
            Facilitates access to Visual Studio's IVsFeatureFlags service
            </summary>
            <remarks>
            <para>
            This is a MEF part which should be imported as follows:
            <code>
            [Import]
            private IFeatureFlagsAdapter featureFlags = null;
            </code>
            </para>
            <para>
            Host specific implementations of this service should be exported as follows:
            <code>
            [ExportImplementation(typeof(IFeatureFlagsAdapter))]
            [Name("My Feature Flags Adapter")]
            [Order(Before = "default")]
            internal sealed class MyFeatureFlagsAdapter : IFeatureFlagsAdapter
            </code>
            </para>
            </remarks>
        </member>
        <member name="M:Microsoft.VisualStudio.Utilities.IFeatureFlagsAdapter.IsFeatureEnabled(System.String,System.Boolean)">
            <summary>
            Queries the Feature Flags service to see whether <paramref name="featureName" /> is enabled.
            </summary>
            <param name="featureName">Name of feature to check</param>
            <param name="defaultValue">Default value to use when request can't be made</param>
            <returns>Whether the feature is enabled</returns>
        </member>
        <member name="M:Microsoft.VisualStudio.Utilities.IFeatureFlagsAdapter.EnableFeatureFlag(System.String,System.Boolean)">
            <summary>
            Enables or disables a feature via the Feature Flags service.
            </summary>
            <param name="featureName">Name of feature to enable/disable.</param>
            <param name="featureFlagValue">Whether to enable or disable the feature.</param>
        </member>
        <member name="T:Microsoft.VisualStudio.Utilities.IGuardedOperations">
            <summary>
            Operations that guard calls to extensions code, track performance and log errors.
            </summary>
            <remarks>This class supports the Visual Studio 
            infrastructure and in general is not intended to be used directly from your code.</remarks>
        </member>
        <member name="M:Microsoft.VisualStudio.Utilities.IGuardedOperations.CallExtensionPoint(System.Action)">
            <summary>
            Makes a guarded call to an extension point.
            </summary>
            <param name="call">Delegate that calls the extension point.</param>
            <remarks>This class supports the Visual Studio 
            infrastructure and in general is not intended to be used directly from your code.</remarks>
        </member>
        <member name="M:Microsoft.VisualStudio.Utilities.IGuardedOperations.CallExtensionPoint(System.Object,System.Action)">
            <summary>
            Makes a guarded call to an extension point.
            </summary>
            <param name="errorSource">Reference to the extension object or event handler that may throw an exception.
            Used for tracking performance and errors.</param>
            <param name="call">Delegate that calls the extension point.</param>
            <remarks>This class supports the Visual Studio 
            infrastructure and in general is not intended to be used directly from your code.</remarks>
        </member>
        <member name="M:Microsoft.VisualStudio.Utilities.IGuardedOperations.CallExtensionPoint(System.Object,System.Action,System.Predicate{System.Exception})">
            <summary>
            Makes a guarded call to an extension point.
            </summary>
            <param name="errorSource">Reference to the extension object or event handler that may throw an exception.
            Used for tracking performance and errors.</param>
            <param name="call">Delegate that calls the extension point.</param>
            <param name="exceptionGuardFilter">Determines which exceptions should be guarded against. 
            An exception gets handled only if <paramref name="exceptionGuardFilter" /> returns <c>true</c>.</param>
            <remarks>This class supports the Visual Studio 
            infrastructure and in general is not intended to be used directly from your code.</remarks>
        </member>
        <member name="M:Microsoft.VisualStudio.Utilities.IGuardedOperations.CallExtensionPoint``1(System.Func{``0},``0)">
            <summary>
            Makes a guarded call to an extension point.
            </summary>
            <param name="call">Delegate that calls the extension point.</param>
            <param name="valueOnThrow">The value returned if the delegate call failed.</param>
            <returns>The result of the <paramref name="call" /> or <paramref name="valueOnThrow" />.</returns>
            <remarks>This class supports the Visual Studio 
            infrastructure and in general is not intended to be used directly from your code.</remarks>
        </member>
        <member name="M:Microsoft.VisualStudio.Utilities.IGuardedOperations.CallExtensionPoint``1(System.Object,System.Func{``0},``0)">
            <summary>
            Makes a guarded call to an extension point.
            </summary>
            <param name="errorSource">Reference to the extension object or event handler that may throw an exception.
            Used for tracking performance and errors.</param>
            <param name="call">Delegate that calls the extension point.</param>
            <param name="valueOnThrow">The value returned if the delegate call failed.</param>
            <returns>The result of the <paramref name="call" /> or <paramref name="valueOnThrow" />.</returns>
            <remarks>This class supports the Visual Studio 
            infrastructure and in general is not intended to be used directly from your code.</remarks>
        </member>
        <member name="M:Microsoft.VisualStudio.Utilities.IGuardedOperations.CallExtensionPointAsync(System.Func{System.Threading.Tasks.Task})">
            <summary>
            Makes a guarded call to an async extension point.
            </summary>
            <param name="asyncAction">Delegate that calls the extension point.</param>
            <returns>A <see cref="T:System.Threading.Tasks.Task" /> that asynchronously executes the <paramref name="asyncAction" />.</returns>
            <remarks>This class supports the Visual Studio 
            infrastructure and in general is not intended to be used directly from your code.</remarks>
        </member>
        <member name="M:Microsoft.VisualStudio.Utilities.IGuardedOperations.CallExtensionPointAsync(System.Object,System.Func{System.Threading.Tasks.Task})">
            <summary>
            Makes a guarded call to an async extension point.
            </summary>
            <remarks>
            The implementation in Visual Studio handles and ignores <see cref="T:System.OperationCanceledException" />.
            </remarks>
            <param name="errorSource">Reference to the extension object or event handler that may throw an exception.
            Used for tracking performance and errors.</param>
            <param name="asyncAction">Delegate that calls the extension point.</param>
            <returns>A <see cref="T:System.Threading.Tasks.Task" /> that asynchronously executes the <paramref name="asyncAction" />.</returns>
            <remarks>This class supports the Visual Studio 
            infrastructure and in general is not intended to be used directly from your code.</remarks>
        </member>
        <member name="M:Microsoft.VisualStudio.Utilities.IGuardedOperations.CallExtensionPointAsync``1(System.Func{System.Threading.Tasks.Task{``0}},``0)">
            <summary>
            Makes a guarded call to an async extension point.
            </summary>
            <remarks>
            The implementation in Visual Studio handles and ignores <see cref="T:System.OperationCanceledException" />.
            </remarks>
            <typeparam name="T">The type of the value returned from the <paramref name="asyncCall" />.</typeparam>
            <param name="asyncCall">Delegate that calls the extension point.</param>
            <param name="valueOnThrow">The value returned if the delegate call failed.</param>
            <returns>A <see cref="T:System.Threading.Tasks.Task`1" /> that asynchronously executes the <paramref name="asyncCall" /> or provides <paramref name="valueOnThrow" />.</returns>
            <remarks>This class supports the Visual Studio 
            infrastructure and in general is not intended to be used directly from your code.</remarks>
        </member>
        <member name="M:Microsoft.VisualStudio.Utilities.IGuardedOperations.CallExtensionPointAsync``1(System.Object,System.Func{System.Threading.Tasks.Task{``0}},``0)">
            <summary>
            Makes a guarded call to an async extension point.
            </summary>
            <remarks>
            The implementation in Visual Studio handles and ignores <see cref="T:System.OperationCanceledException" />.
            </remarks>
            <typeparam name="T">The type of the value returned from the <paramref name="asyncCall" />.</typeparam>
            <param name="errorSource">Reference to the extension object or event handler that may throw an exception.
            Used for tracking performance and errors.</param>
            <param name="asyncCall">Delegate that calls the extension point.</param>
            <param name="valueOnThrow">The value returned if the delegate call failed.</param>
            <returns>A <see cref="T:System.Threading.Tasks.Task`1" /> that asynchronously executes the <paramref name="asyncCall" /> or provides <paramref name="valueOnThrow" />.</returns>
            <remarks>This class supports the Visual Studio 
            infrastructure and in general is not intended to be used directly from your code.</remarks>
        </member>
        <member name="M:Microsoft.VisualStudio.Utilities.IGuardedOperations.FindEligibleFactories``2(System.Collections.Generic.IEnumerable{System.Lazy{``0,``1}},Microsoft.VisualStudio.Utilities.IContentType,Microsoft.VisualStudio.Utilities.IContentTypeRegistryService)">
            <summary>
            Selects extension factories whose declared content type metadata
            matches the provided target content type, taking into account that extension factory
            may be disabled by a Replace attribute on another factory.
            </summary>
            <param name="lazyFactories">Lazy references that will be evaluated.</param>
            <param name="dataContentType">Target content type.</param>
            <param name="contentTypeRegistryService">Instance of <see cref="T:Microsoft.VisualStudio.Utilities.IContentTypeRegistryService" /> which orders content types.</param>
            <remarks>This class supports the Visual Studio 
            infrastructure and in general is not intended to be used directly from your code.</remarks>
        </member>
        <member name="M:Microsoft.VisualStudio.Utilities.IGuardedOperations.HandleException(System.Object,System.Exception)">
            <summary>
            Handles an exception occured in a call to an extension point.
            </summary>
            <param name="errorSource">Reference to the extension object or event handler that threw the exception</param>
            <param name="e">Exception to handle</param>
            <remarks>This class supports the Visual Studio 
            infrastructure and in general is not intended to be used directly from your code.
            In Visual Studio, this method logs the exception to ActivityLogs and the telemetry, and displays an error message to the user if possible.
            This method can be invoked from any thread.</remarks>
        </member>
        <member name="M:Microsoft.VisualStudio.Utilities.IGuardedOperations.InstantiateExtension``1(System.Object,System.Lazy{``0})">
            <summary>
            Safely instantiates an extension point.
            </summary>
            <param name="errorSource">Reference to the object that will be blamed for potential exceptions.</param>
            <param name="provider">Lazy reference that will be initialized.</param>
            <returns>Initialized instance stored in <paramref name="provider" />.</returns>
            <remarks>This class supports the Visual Studio 
            infrastructure and in general is not intended to be used directly from your code.</remarks>
        </member>
        <member name="M:Microsoft.VisualStudio.Utilities.IGuardedOperations.InstantiateExtension``2(System.Object,System.Lazy{``0,``1})">
            <summary>
            Safely instantiates an extension point.
            </summary>
            <param name="errorSource">Reference to the object that will be blamed for potential exceptions.</param>
            <param name="provider">Lazy reference that will be initialized.</param>
            <returns>Initialized instance stored in <paramref name="provider" />.</returns>
            <remarks>This class supports the Visual Studio 
            infrastructure and in general is not intended to be used directly from your code.</remarks>
        </member>
        <member name="M:Microsoft.VisualStudio.Utilities.IGuardedOperations.InstantiateExtension``3(System.Object,System.Lazy{``0,``1},System.Func{``0,``2})">
            <summary>
            Safely invokes a delegate on the extension point.
            </summary>
            <param name="errorSource">Reference to the object that will be blamed for potential exceptions.</param>
            <param name="provider">Lazy reference that will be initialized.</param>
            <param name="getter">Delegate which constructs an instance of the extension from its <paramref name="provider" />.</param>
            <returns>The result of <paramref name="getter" />.</returns>
            <remarks>This class supports the Visual Studio 
            infrastructure and in general is not intended to be used directly from your code.</remarks>
        </member>
        <member name="M:Microsoft.VisualStudio.Utilities.IGuardedOperations.InvokeBestMatchingFactory``2(System.Collections.Generic.IList{System.Lazy{``0,``1}},Microsoft.VisualStudio.Utilities.IContentType,Microsoft.VisualStudio.Utilities.IContentTypeRegistryService,System.Object)">
            <summary>
            Safely instantiates an extension point whose declared content type metadata
            is the closest match to the provided target content type.
            </summary>
            <param name="providerHandles">Lazy references that will be evaluated.</param>
            <param name="dataContentType">Target content type.</param>
            <param name="contentTypeRegistryService">Instance of <see cref="T:Microsoft.VisualStudio.Utilities.IContentTypeRegistryService" /> which orders content types.</param>
            <param name="errorSource">Reference to the object that will be blamed for potential exceptions.</param>
            <returns>The selected element of <paramref name="providerHandles" />.</returns>
            <remarks>This class supports the Visual Studio 
            infrastructure and in general is not intended to be used directly from your code.</remarks>
        </member>
        <member name="M:Microsoft.VisualStudio.Utilities.IGuardedOperations.InvokeBestMatchingFactory``3(System.Collections.Generic.IList{System.Lazy{``0,``2}},Microsoft.VisualStudio.Utilities.IContentType,System.Func{``0,``1},Microsoft.VisualStudio.Utilities.IContentTypeRegistryService,System.Object)">
            <summary>
            Safely invokes a delegate on the extension factory whose declared content type metadata
            is the best match to the provided target content type.
            </summary>
            <param name="providerHandles">Lazy references that will be evaluated.</param>
            <param name="dataContentType">Target content type.</param>
            <param name="getter">Delegate which constructs an instance of the extension from the best matching element of <paramref name="providerHandles" />.</param>
            <param name="contentTypeRegistryService">Instance of <see cref="T:Microsoft.VisualStudio.Utilities.IContentTypeRegistryService" /> which orders content types.</param>
            <param name="errorSource">Reference to the object that will be blamed for potential exceptions.</param>
            <returns>The result of <paramref name="getter" />.</returns>
            <remarks>This class supports the Visual Studio 
            infrastructure and in general is not intended to be used directly from your code.</remarks>
        </member>
        <member name="M:Microsoft.VisualStudio.Utilities.IGuardedOperations.InvokeEligibleFactories``3(System.Collections.Generic.IEnumerable{System.Lazy{``1,``2}},System.Func{``1,``0},Microsoft.VisualStudio.Utilities.IContentType,Microsoft.VisualStudio.Utilities.IContentTypeRegistryService,System.Object)">
            <summary>
            Safely invokes a delegate on all extension factories whose declared content type metadata
            matches the provided target content type, taking into account that extension factory
            may be disabled by a Replace attribute on another factory.
            </summary>
            <param name="lazyFactories">Lazy references that will be evaluated.</param>
            <param name="getter">Delegate which constructs an instance of the extension from each element of <paramref name="lazyFactories" />.</param>
            <param name="dataContentType">Target content type.</param>
            <param name="contentTypeRegistryService">Instance of <see cref="T:Microsoft.VisualStudio.Utilities.IContentTypeRegistryService" /> which orders content types.</param>
            <param name="errorSource">Reference to the object that will be blamed for potential exceptions.</param>
            <returns>The list of results of <paramref name="getter" />.</returns>
            <remarks>This class supports the Visual Studio 
            infrastructure and in general is not intended to be used directly from your code.</remarks>
        </member>
        <member name="M:Microsoft.VisualStudio.Utilities.IGuardedOperations.InvokeMatchingFactories``3(System.Collections.Generic.IEnumerable{System.Lazy{``1,``2}},System.Func{``1,``0},Microsoft.VisualStudio.Utilities.IContentType,System.Object)">
            <summary>
            Safely invokes a delegate on all extension factories whose declared content type metadata
            matches the provided target content type.
            </summary>
            <param name="lazyFactories">Lazy references that will be evaluated.</param>
            <param name="getter">Delegate which constructs an instance of the extension from each element of <paramref name="lazyFactories" />.</param>
            <param name="dataContentType">Target content type.</param>
            <param name="errorSource">Reference to the object that will be blamed for potential exceptions.</param>
            <returns>The list of results of <paramref name="getter" />.</returns>
            <remarks>This class supports the Visual Studio 
            infrastructure and in general is not intended to be used directly from your code.</remarks>
        </member>
        <member name="M:Microsoft.VisualStudio.Utilities.IGuardedOperations.RaiseEvent(System.Object,System.EventHandler)">
            <summary>
            Safely raises an event with empty <see cref="T:System.EventArgs" />.
            Errors are tracked per sender, performance is tracked per handler.
            </summary>
            <param name="sender">Reference to the sender of the event. Tracks errors.</param>
            <param name="eventHandlers">Event to raise. Each handler tracks performance.</param>
            <remarks>This class supports the Visual Studio 
            infrastructure and in general is not intended to be used directly from your code.</remarks>
        </member>
        <member name="M:Microsoft.VisualStudio.Utilities.IGuardedOperations.RaiseEvent``1(System.Object,System.EventHandler{``0},``0)">
            <summary>
            Safely raises an event with specified <paramref name="args" />.
            Errors are tracked per sender, performance is tracked per handler.
            </summary>
            <param name="sender">Reference to the sender of the event. Tracks errors.</param>
            <param name="eventHandlers">Event to raise. Each handler tracks performance.</param>
            <param name="args">Event data.</param>
            <remarks>This class supports the Visual Studio 
            infrastructure and in general is not intended to be used directly from your code.</remarks>
        </member>
        <member name="M:Microsoft.VisualStudio.Utilities.IGuardedOperations.RaiseEventOnBackgroundAsync``1(System.Object,Microsoft.VisualStudio.Threading.AsyncEventHandler{``0},``0)">
            <summary>
            Safely raises an event on a background thread with specified <paramref name="args" />.
            Errors are tracked per sender, performance is tracked per handler.
            </summary>
            <param name="sender">Reference to the sender of the event. Tracks errors.</param>
            <param name="eventHandlers">Event to raise. Each handler tracks performance.</param>
            <param name="args">Event data.</param>
            <returns>A <see cref="T:System.Threading.Tasks.Task" /> that asynchronously executes the <paramref name="eventHandlers" />.</returns>
            <remarks>This class supports the Visual Studio 
            infrastructure and in general is not intended to be used directly from your code.</remarks>
        </member>
        <member name="M:Microsoft.VisualStudio.Utilities.IGuardedOperations.TryCastToType``1(System.Object,``0@)">
            <summary>
            Safely attempts to cast the given object to the given type.
            </summary>
            <typeparam name="TArgs">The type that should be casted to.</typeparam>
            <param name="toCast">The object that should be casted.</param>
            <param name="casted">Returns out the casted object or default(TArgs) if the cast failed.</param>
            <returns>True if successful in casting, false otherwise.</returns>
        </member>
        <member name="T:Microsoft.VisualStudio.Utilities.IGuardedOperations2">
            <summary>
            Operations that guard calls to extensions code, track performance and log errors.
            </summary>
            <remarks>This class supports the Visual Studio 
            infrastructure and in general is not intended to be used directly from your code.</remarks>
        </member>
        <member name="M:Microsoft.VisualStudio.Utilities.IGuardedOperations2.LogException(System.Object,System.Exception)">
            <summary>
            Logs an exception silently, without notifying the user.
            </summary>
            <param name="errorSource">Reference to the extension object or event handler that threw the exception</param>
            <param name="e">Exception to log</param>
            <remarks>This method can be invoked from any thread.</remarks>
        </member>
        <member name="T:Microsoft.VisualStudio.Utilities.IGuardedOperationsInternal">
            <summary>
            Operations that guard calls to extensions code, track performance and log errors.
            This interface contains method signatures which will be moved to <see cref="T:Microsoft.VisualStudio.Utilities.IGuardedOperations" />
            in future releases of Visual Studio. Microsoft reserves the right to modify this interface.
            </summary>
            <remarks>This class supports the Visual Studio 
            infrastructure and in general is not intended to be used directly from your code.</remarks>
        </member>
        <member name="M:Microsoft.VisualStudio.Utilities.IGuardedOperationsInternal.CallExtensionPoint``1(System.Object,System.Func{``0},``0,System.Predicate{System.Exception},System.Predicate{System.Exception})">
            <summary>
            Makes a guarded call to an extension point.
            </summary>
            <param name="errorSource">Reference to the extension object or event handler that may throw an exception.
            Used for tracking performance and errors.</param>
            <param name="call">Delegate that calls the extension point.</param>
            <param name="valueOnThrow">The value returned if the delegate call failed.</param>
            <param name="exceptionToIgnore">Determines which exceptions should be ignored. This predicate is evaluated first</param>
            <param name="exceptionToHandle">Determines which exceptions should be logged. This predicate is evaluated second.
            If both predicates return <c>false</c>, then the exceptions remains unhandled and may be caught in the calling code.</param>
            <returns>The result of the <paramref name="call" /> or <paramref name="valueOnThrow" />.</returns>
            <remarks>This class supports the Visual Studio 
            infrastructure and in general is not intended to be used directly from your code.</remarks>
            <example>
            The following code will synchronously call <c>extension.GetData()</c>.
            exceptionToIgnore predicate prevents logging the <c>OperationCanceledException</c> when relevant cancellation token is canceled.
            exceptionToHandle predicate causes all other exceptions to be logged.
            If both predicates returned false, the exception would remain unhandled and may be caught in the calling code.
            <code>
            var result = GuardedOperations.CallExtensionPoint(
                             errorSource: extension,
                             call: () =&gt; extension.GetData(token),
                             valueOnThrow: string.Empty,
                             exceptionToIgnore: (e) =&gt; e is OperationCanceledException &amp;&amp; token.IsCancellationRequested,
                             exceptionToHandle: (e) =&gt; true);
            </code>
            </example>
        </member>
        <member name="M:Microsoft.VisualStudio.Utilities.IGuardedOperationsInternal.FindAllEligibleFactories``2(System.Collections.Generic.IEnumerable{System.Lazy{``0,``1}},Microsoft.VisualStudio.Utilities.IContentType,Microsoft.VisualStudio.Utilities.IContentTypeRegistryService)">
            <summary>
            Selects extension factories whose declared content type metadata
            matches the provided target content type, taking into account that extension factory
            may be disabled by a Replace attribute on another factory.
            For factories that replace other factories, return value also contains the replaced factory.
            </summary>
            <param name="lazyFactories">Lazy references that will be evaluated.</param>
            <param name="dataContentType">Target content type.</param>
            <param name="contentTypeRegistryService">Instance of <see cref="T:Microsoft.VisualStudio.Utilities.IContentTypeRegistryService" /> which orders content types.</param>
        </member>
        <member name="M:Microsoft.VisualStudio.Utilities.IGuardedOperationsInternal.FindBestMatchingFactory``2(System.Collections.Generic.IList{System.Lazy{``0,``1}},Microsoft.VisualStudio.Utilities.IContentType,Microsoft.VisualStudio.Utilities.IContentTypeRegistryService)">
            <summary>
            Finds an extension point whose declared content type metadata
            is the closest match to the provided target content type.
            </summary>
            <param name="providerHandles">Lazy references that will be evaluated.</param>
            <param name="dataContentType">Target content type.</param>
            <param name="contentTypeRegistryService">Instance of <see cref="T:Microsoft.VisualStudio.Utilities.IContentTypeRegistryService" /> which orders content types.</param>
            <returns>The selected element of <paramref name="providerHandles" />.</returns>
            <remarks>This class supports the Visual Studio 
            infrastructure and in general is not intended to be used directly from your code.</remarks>
        </member>
        <member name="T:Microsoft.VisualStudio.Utilities.IMemoryLeakTrackerService">
             <summary>
             Interface to track object in Memory.
             </summary>
             <example>
             Usage:
                 1. To track the object you desire to see if it leaks or not, in the constructor of the object call the method <see cref="M:Microsoft.VisualStudio.Utilities.IMemoryLeakTrackerService.TrackObject``1(``0,System.String,Microsoft.VisualStudio.Utilities.ILivingObjectDiagnostics{``0})" />
                Note: This is the only method that should be called in the product code.
            
             <code>
                 [Import]
                 internal IMemoryLeakTrackerService MemoryLeakTrackerService { get; set; }
                 MemoryLeakTrackerService.TrackObject&lt;ITextView&gt;(this, this.GetIdentifier(), objectDiagnosticHelper);
             </code>
            
                 where this.GetIdentifier returns a string that identifies the object of the type uniquely.
                 and objectDiagnosticHelper is a static object of type <see cref="T:Microsoft.VisualStudio.Utilities.ILivingObjectDiagnostics`1" />
            
                 The implementation of <see cref="T:Microsoft.VisualStudio.Utilities.ILivingObjectDiagnostics`1" /> cannot contain any instance variables in it.
                 It should only serve to take in an object of type T to help get its preview or check if its considered to be collected by the component.
            
                 2. To check if the object being tracked is leaking or not, for telemetry or test purposes.
            
             <code>
                 var allAliveObjects = MemoryLeakTrackerService.GetLivingObjects&lt;ITextView&gt;();
                 foreach(var aliveObject in aliveObjects)
                 {
                     if(aliveObject.HasProbablyLeaked())
                     {
                             // This might be a potential leak
                             // Log Telemetry or throw. For Diagnostics use aliveObject.GetPreview();
                     }
                 }
             </code>
             </example>
        </member>
        <member name="M:Microsoft.VisualStudio.Utilities.IMemoryLeakTrackerService.TrackObject``1(``0,System.String,Microsoft.VisualStudio.Utilities.ILivingObjectDiagnostics{``0})">
            <summary>
            Track object lifecycle in memory. Is free threaded. Called in product code. Does not throw.
            </summary>
            <param name="objectToTrack">Generic templated object type to track.</param>
            <param name="identifier">Unique identifier for the object being tracked</param>
            <param name="objectDiagnosticsHelper">A static object implementing <see cref="T:Microsoft.VisualStudio.Utilities.ILivingObjectDiagnostics`1"> to help clients of the service to get diagnostics support for the object being tracked</see>/&gt;</param>
        </member>
        <member name="M:Microsoft.VisualStudio.Utilities.IMemoryLeakTrackerService.GetLivingObjects``1">
            <summary>
            Get snapshot of all living object in memory. May require UI thread depending on the object being tracked. Only supposed to be called in Telemetry or Test code.
            </summary>
        </member>
        <member name="M:Microsoft.VisualStudio.Utilities.IMemoryLeakTrackerService.GetLivingObjects">
            <summary>
            Gets snapshot of all living objects currently. May require UI thread depending on the object being tracked. Only supposed to be called in Telemetry or Test code.
            </summary>
        </member>
        <member name="M:Microsoft.VisualStudio.Utilities.IMemoryLeakTrackerService.RefreshWeakRefrenceCache">
            <summary>
            Refreshes the cache to get rid of all weak references that are not alive. Usually called before taking a measurement.
            </summary>
        </member>
        <member name="M:Microsoft.VisualStudio.Utilities.IMemoryLeakTrackerService.ClearCache">
            <summary>
            Clears the cache of all entries. Not to be called from product code. Used by test code or extensions when they have to start off a clear list.
            </summary>
        </member>
        <member name="P:Microsoft.VisualStudio.Utilities.IMemoryLeakTrackerService.WasCacheResettedBefore">
            <summary>
            A flag to indicate whether the cache has been resetted before.
            </summary>
        </member>
        <member name="P:Microsoft.VisualStudio.Utilities.IMemoryLeakTrackerService.IsTracking">
            <summary>
            Flag to start or stop the tracking service
            </summary>
        </member>
        <member name="T:Microsoft.VisualStudio.Utilities.ILivingObjectDiagnostics`1">
            <summary>
            Helper class to check if an object of Type T is considered to be collected or not and to get a quick preview of the object.
            Implementers of this class are not allowed to have state, otherwise they will cause a leak.
            Only one static object per type T of the implementation should ever exist.
            </summary>
        </member>
        <member name="M:Microsoft.VisualStudio.Utilities.ILivingObjectDiagnostics`1.HasProbablyLeaked(`0)">
            <summary>
             This method may require UI thread access depending on the implementation
            </summary>
        </member>
        <member name="M:Microsoft.VisualStudio.Utilities.ILivingObjectDiagnostics`1.GetPreview(`0)">
             This method may require UI thread access depending on the implementation
        </member>
        <member name="M:Microsoft.VisualStudio.Utilities.ILivingObjectDiagnostics`1.GetDescription(`0)">
             This method may require UI thread access depending on the implementation
        </member>
        <member name="T:Microsoft.VisualStudio.Utilities.ImportImplementationsAttribute">
             <summary>
             Along with <see cref="T:Microsoft.VisualStudio.Utilities.ExportImplementationAttribute" /> enables MEF proxy pattern where a single component export serves
             as a proxy for the best implementation selected at run time. This pattern allows component consumers to just [Import] it,
             hiding the complexity of selecting one of implementations.
             </summary>
             <example>
             A typical sample:
            
             A component contract definition:
            
             <code>
             interface IService {
                 void Foo();
             }
             </code>
            
             Default implementation:
            
             <code>
             [ExportImplementation(typeof(IService))]
             [Name("default")]
             class DefaultService : IService {...}
             </code>
            
             Another implementation:
            
             <code>
             [ExportImplementation(typeof(IService))]
             [Name("A better implementation")]
             [Order(Before = "default")]
             class AdvancedService : IService {...}
             </code>
            
             A proxy:
            
             <code>
             [Export(typeof(IService))]
             class ProxyService : IService {
                [ImportImplementations(typeof(IService))]
                IEnumerable&lt;Lazy&lt;IService, IOrderable&gt;&gt; _unorderedImplementations;
                
                public void Foo() {
                    Orderer.Order(_unorderedImplementations).FirstOrDefault()?.Value.Foo();
                }
             }
             </code>
            
             Consuming IService:
            
             <code>
             [Import]
             IService service = null;
             </code>
             </example>
        </member>
        <member name="M:Microsoft.VisualStudio.Utilities.ImportImplementationsAttribute.#ctor(System.Type)">
            <summary>
            Creates new <see cref="T:Microsoft.VisualStudio.Utilities.ImportImplementationsAttribute" /> instance.
            </summary>
            <param name="contractType">A contract type.</param>
        </member>
        <member name="M:Microsoft.VisualStudio.Utilities.ImportImplementationAttribute.#ctor(System.Type)">
            <summary>
            Creates new <see cref="T:Microsoft.VisualStudio.Utilities.ImportImplementationAttribute" /> instance.
            </summary>
            <param name="contractType">A contract type.</param>
        </member>
        <member name="T:Microsoft.VisualStudio.Utilities.INamed">
            <summary>
            Represents an object that provides a localized display name
            to be used when it's being represented to the user, for
            example when blaming for delays.
            </summary>
        </member>
        <member name="P:Microsoft.VisualStudio.Utilities.INamed.DisplayName">
            <summary>
            Gets display name of an instance used to represent it to the user, for
            example when blaming it for delays.
            </summary>
        </member>
        <member name="T:Microsoft.VisualStudio.Utilities.IOrderable">
            <summary>
            Associated with an orderable part. 
            </summary>
            <remarks>This interface is helpful when importing orderable parts.</remarks> 
        </member>
        <member name="P:Microsoft.VisualStudio.Utilities.IOrderable.Name">
            <summary>
            Uniquely identifies a part with respect to parts of the same type.
            </summary>
        </member>
        <member name="P:Microsoft.VisualStudio.Utilities.IOrderable.Before">
            <summary>
            The parts before which this part should appear in the list.
            </summary>
        </member>
        <member name="P:Microsoft.VisualStudio.Utilities.IOrderable.After">
            <summary>
            The parts after which this part should appear in the list.
            </summary>
        </member>
        <member name="T:Microsoft.VisualStudio.Utilities.IPropertyOwner">
            <summary>
            Provides ownership of an arbitrary set of properties.
            </summary>
            <remarks>This interface should be implemented for classes that need to control the lifetimes of their properties.</remarks>
        </member>
        <member name="P:Microsoft.VisualStudio.Utilities.IPropertyOwner.Properties">
            <summary>
            The collection of properties controlled by the property owner.
            </summary>
        </member>
        <member name="T:Microsoft.VisualStudio.Utilities.ITelemetryIdProvider`1">
            <summary>
            Represents an object that can provide a unique ID for telemetry purposes.
            </summary>
            <remarks><typeparam name="TId">Type of the telemetry ID.</typeparam></remarks>
        </member>
        <member name="M:Microsoft.VisualStudio.Utilities.ITelemetryIdProvider`1.TryGetTelemetryId(`0@)">
            <summary>
            Tries to get a unique ID for telemetry purposes.
            </summary>
            <returns><c>true</c> if a unique telemetry ID was returned, <c>false</c> if this object refuses to participate in telemetry logging.</returns>
        </member>
        <member name="T:Microsoft.VisualStudio.Utilities.LivingObjectRecord`1">
            <summary>
            Generic way to get diagnostic information about living objects of a specific type T
            </summary>
        </member>
        <member name="M:Microsoft.VisualStudio.Utilities.LivingObjectRecord`1.#ctor(`0,System.String,System.String,System.Boolean,System.String)">
            <summary>
            Constructor to create a record of the living object in memory. 
            </summary>
        </member>
        <member name="P:Microsoft.VisualStudio.Utilities.LivingObjectRecord`1.LivingObject">
            <summary>
            The object being leaked. Do not pass to telemetry directly as it may contain PII.  Not suitable for telemetry. Used by partners or tests.
            Please note if the actual object represented by the weak reference should be held for a very short time for test or telemetry purposes only.
            </summary>
        </member>
        <member name="T:Microsoft.VisualStudio.Utilities.LivingObjectRecord">
            <summary>
            Generic way to get diagnostic information about living objects without a specific type T 
            </summary>
        </member>
        <member name="P:Microsoft.VisualStudio.Utilities.LivingObjectRecord.HasProbablyLeaked">
            <summary>
            Quick way to tell if the object that's alive is a leak or not.
            If true and sufficient time for garbage collection is allowed then the object is most likely a memory leak
            </summary>
        </member>
        <member name="P:Microsoft.VisualStudio.Utilities.LivingObjectRecord.Identifier">
            <summary>
            Identifier for the current object. May contain PII. Not suitable for telemetry. Used by partners or tests.
            </summary>
        </member>
        <member name="P:Microsoft.VisualStudio.Utilities.LivingObjectRecord.Preview">
            <summary>
            Preview for the object to help diagnose the leak quickly. May contain PII. Not suitable for telemetry. Used by partners or tests. 
            </summary>
        </member>
        <member name="P:Microsoft.VisualStudio.Utilities.LivingObjectRecord.Description">
            <summary>
            Description of the object being tracked so that can be displayed in human readable format apart from identifier. Usually shorter than a full preview. May contain PII. Not suitable for telemetry. Used by partners or tests. 
            </summary>
        </member>
        <member name="T:Microsoft.VisualStudio.Utilities.LocalizedNameAttribute">
            <summary>
            Represents an attribute which can provide a localized name as metadata for a MEF extension.
            </summary>
        </member>
        <member name="F:Microsoft.VisualStudio.Utilities.LocalizedNameAttribute.localizedName">
            <summary>
            Note: the localized name is cached rather than the type to prevent
            MEF from referencing the type in its cache.  Types exposed as metadata
            cause MEF to load the assembly containing the type during composition.
            </summary>
        </member>
        <member name="M:Microsoft.VisualStudio.Utilities.LocalizedNameAttribute.#ctor(System.Type,System.String)">
            <summary>
            Creates an instance of this attribute, which caches the localized name represented
            by the given type and resource name.
            </summary>
            <param name="type">The type from which to load the localized resource.  This should
            be a type created by the resource designer.</param>
            <param name="resourceId">The name of the localized resource string contained the
            resource type.</param>
        </member>
        <member name="M:Microsoft.VisualStudio.Utilities.LocalizedNameAttribute.#ctor(System.Type,System.String,System.String)">
            <summary>
            Creates an instance of this attribute, which caches the localized name represented
            by the given type and resource name.
            </summary>
            <param name="type">The type from which to load the localized resource.</param>
            <param name="resourceStreamName">The base name of the resource stream containing the resource.</param>
            <param name="resourceId">The name of the localized resource string contained the
            resource type.</param>
        </member>
        <member name="P:Microsoft.VisualStudio.Utilities.LocalizedNameAttribute.LocalizedName">
            <summary>
            Gets the localized name specified by the constructor.
            </summary>
        </member>
        <member name="T:Microsoft.VisualStudio.Utilities.MultipleBaseMetadataAttribute">
            <summary>
            A base class for attributes that can appear multiple times on a single component part.
            </summary>
        </member>
        <member name="T:Microsoft.VisualStudio.Utilities.NameAttribute">
            <summary>
            Associates a name with an editor extension part.
            </summary>
        </member>
        <member name="M:Microsoft.VisualStudio.Utilities.NameAttribute.#ctor(System.String)">
            <summary>
            Constructs a new instance of the attribute.
            </summary>
            <param name="name">The name of the editor extension part.</param>
            <exception cref="T:System.ArgumentNullException"><paramref name="name" /> is null.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="name" /> is an empty string.</exception>
        </member>
        <member name="P:Microsoft.VisualStudio.Utilities.NameAttribute.Name">
            <summary>
            The name of the editor extension part.
            </summary>
        </member>
        <member name="T:Microsoft.VisualStudio.Utilities.OptionUserModifiableAttribute">
            <summary>
            A MEF attribute determining if an option is user modifiable.
            </summary>
        </member>
        <member name="M:Microsoft.VisualStudio.Utilities.OptionUserModifiableAttribute.#ctor(System.Boolean)">
            <summary>
            Initializes a new instance of the <see cref="T:Microsoft.VisualStudio.Utilities.OptionUserModifiableAttribute" />.
            </summary>
            <param name="userModifiable"><c>true</c> if the option is user modifiable; otherwise <c>false</c>.</param>
        </member>
        <member name="P:Microsoft.VisualStudio.Utilities.OptionUserModifiableAttribute.OptionUserModifiable">
            <summary>
            Determines whether the option is modifiable to the user.
            </summary>
        </member>
        <member name="T:Microsoft.VisualStudio.Utilities.OptionUserVisibleAttribute">
            <summary>
            A MEF attribute determining if an option is visible to the user.
            </summary>
        </member>
        <member name="M:Microsoft.VisualStudio.Utilities.OptionUserVisibleAttribute.#ctor(System.Boolean)">
            <summary>
            Initializes a new instance of the <see cref="T:Microsoft.VisualStudio.Utilities.OptionUserVisibleAttribute" />.
            </summary>
            <param name="userVisible"><c>true</c> if the option is visible to the user; otherwise <c>false</c>.</param>
        </member>
        <member name="P:Microsoft.VisualStudio.Utilities.OptionUserVisibleAttribute.OptionUserVisible">
            <summary>
            Determines whether the option is visible to the user.
            </summary>
        </member>
        <member name="T:Microsoft.VisualStudio.Utilities.OrderAttribute">
            <summary>
            Orders multiple instances of an extension part.
            </summary>
        </member>
        <member name="P:Microsoft.VisualStudio.Utilities.OrderAttribute.Before">
            <summary>
            The extension part to which this attribute is applied should be ordered before 
            the extension part with the name specified.
            </summary>
            <exception cref="T:System.ArgumentNullException">The value is null.</exception>
            <exception cref="T:System.ArgumentException">The value is an empty string.</exception>
        </member>
        <member name="P:Microsoft.VisualStudio.Utilities.OrderAttribute.After">
            <summary>
            The extension part to which this attribute is applied should be ordered after
            the extension part with the name specified.
            </summary>
            <exception cref="T:System.ArgumentNullException">The value is null.</exception>
            <exception cref="T:System.ArgumentException">The value is an empty string.</exception>
        </member>
        <member name="T:Microsoft.VisualStudio.Utilities.Orderer">
            <summary>
            Performs a topological sort of orderable extension parts.
            </summary>
        </member>
        <member name="M:Microsoft.VisualStudio.Utilities.Orderer.Order``2(System.Collections.Generic.IEnumerable{System.Lazy{``0,``1}})">
            <summary>
            Orders a list of items that are all orderable, that is, items that implement the <see cref="T:Microsoft.VisualStudio.Utilities.IOrderable" /> interface. 
            </summary>
            <param name="itemsToOrder">The list of items to sort.</param>
            <returns>The list of sorted items.</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="itemsToOrder" /> is null.</exception>
        </member>
        <member name="T:Microsoft.VisualStudio.Utilities.PriorityAttribute">
            <summary>
            Represents an attribute which assigns an integer priority to a MEF component part.
            </summary>
        </member>
        <member name="M:Microsoft.VisualStudio.Utilities.PriorityAttribute.#ctor(System.Int32)">
            <summary>
            Creates a new instance of this attribute, assigning it a priority value.
            </summary>
            <param name="priority">The priority for the MEF component part.  Lower integer
            values represent higher precedence.</param>
        </member>
        <member name="P:Microsoft.VisualStudio.Utilities.PriorityAttribute.Priority">
            <summary>
            Gets the priority for the attributed MEF extension.
            </summary>
        </member>
        <member name="T:Microsoft.VisualStudio.Utilities.PropertyCollection">
            <summary>
            Allows property owners to control the lifetimes of the properties in the collection. 
            </summary>
            <remarks>This collection is synchronized in order to allow access by multiple threads.</remarks>
        </member>
        <member name="M:Microsoft.VisualStudio.Utilities.PropertyCollection.AddProperty(System.Object,System.Object)">
            <summary>
            Adds a new property to the collection.
            </summary>
            <param name="key">The key by which the property can be retrieved. Must be non-null.</param>
            <param name="property">The property to associate with the key.</param>
            <exception cref="T:System.ArgumentException">An element with the same key already exists in the PropertyCollection.</exception>
            <exception cref="T:System.ArgumentNullException"><paramref name="key" /> is null.</exception>
        </member>
        <member name="M:Microsoft.VisualStudio.Utilities.PropertyCollection.RemoveProperty(System.Object)">
            <summary>
            Removes the property associated with the specified key.
            </summary>
            <param name="key">The key of the property to remove.</param>
            <returns><c>true</c> if the property was found and removed, <c>false</c> if the property was not found.</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="key" /> is null.</exception>
        </member>
        <member name="M:Microsoft.VisualStudio.Utilities.PropertyCollection.GetOrCreateSingletonProperty``1(System.Object,System.Func{``0})">
            <summary>
            Gets or creates a property of type <typeparamref name="T" /> from the property collection. If
            there is already a property with the specified <paramref name="key" />, returns the existing property. Otherwise,
            uses <paramref name="creator" /> to create an instance of that type and add it to the collection with the specified <paramref name="key" />.
            </summary>
            <typeparam name="T">The type of the property.</typeparam>
            <param name="key">The key of the property to get or create.</param>
            <param name="creator">The delegate used to create the property (if needed).</param>
            <returns>The property that was requested.</returns>
        </member>
        <member name="M:Microsoft.VisualStudio.Utilities.PropertyCollection.GetOrCreateSingletonProperty``1(System.Func{``0})">
            <summary>
            Gets or creates a property of type <typeparamref name="T" /> from the property collection. If
            there is already a property of that type, it returns the existing property. Otherwise, it
            uses <paramref name="creator" /> to create an instance of that type.
            </summary>
            <typeparam name="T">The type of the property.</typeparam>
            <param name="creator">The delegate used to create the property (if needed).</param>
            <returns>An instance of the property.</returns>
            <remarks>The key used in the property collection will be typeof(T).</remarks>
        </member>
        <member name="M:Microsoft.VisualStudio.Utilities.PropertyCollection.GetProperty``1(System.Object)">
            <summary>
            Gets the property associated with the specified key.
            </summary>
            <param name="key">The key.</param>
            <returns>The property value, or null if the property is not set.</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="key" /> is null.</exception>
            <exception cref="T:System.Collections.Generic.KeyNotFoundException"><paramref name="key" /> does not exist in the property collection.</exception>
        </member>
        <member name="M:Microsoft.VisualStudio.Utilities.PropertyCollection.GetProperty(System.Object)">
            <summary>
            Gets the property associated with the specified key.
            </summary>
            <param name="key">The key.</param>
            <returns>The property value, or null if the property is not set.</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="key" /> is null.</exception>
            <exception cref="T:System.Collections.Generic.KeyNotFoundException"><paramref name="key" /> does not exist in the property collection.</exception>
        </member>
        <member name="M:Microsoft.VisualStudio.Utilities.PropertyCollection.TryGetProperty``1(System.Object,``0@)">
            <summary>
            Gets the property associated with the specified key.
            </summary>
            <typeparam name="TProperty">The type of the property associated with the specified key.</typeparam>
            <param name="key">The key.</param>
            <param name="property">The retrieved property, or default(TValue) if there is
            no property associated with the specified key.</param>
            <returns><c>true</c> if the property was found, otherwise <c>false</c>.</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="key" /> is null.</exception>
        </member>
        <member name="M:Microsoft.VisualStudio.Utilities.PropertyCollection.Exchange``1(System.Object,``0)">
            <summary>
            Replaces the entry associated with <paramref name="key" /> with value, returning the old value (or default(T)). This is done as a thread-safe/atomic operation.
            </summary>
            <returns>The original entry associated with <paramref name="key" /> or default(<typeparamref name="T" />) if there was no value associated with the <paramref name="key" />.</returns>
        </member>
        <member name="M:Microsoft.VisualStudio.Utilities.PropertyCollection.CompareExchange``1(System.Object,``0,``0)">
            <summary>
            Compares the entry associated with <paramref name="key" /> for equality with value and, if they are <see cref="M:System.Object.Equals(System.Object,System.Object)" />,
            replaces the entry with <paramref name="value" />. This is done as a thread-safe/atomic operation.
            </summary>
            <returns>The original entry associated with <paramref name="key" />.</returns>
            <remarks>
            If no value was associated with <paramref name="key" />, then default(<typeparamref name="T" />) is used.
            </remarks>
        </member>
        <member name="M:Microsoft.VisualStudio.Utilities.PropertyCollection.ContainsProperty(System.Object)">
            <summary>
            Determines whether the property collection contains a property for the specified key.
            </summary>
            <param name="key">The key.</param>
            <returns><c>true</c> if the property exists, otherwise <c>false</c>.</returns>
        </member>
        <member name="P:Microsoft.VisualStudio.Utilities.PropertyCollection.Item(System.Object)">
            <summary>
            Gets or sets the <see cref="T:System.Object" /> with the specified key.
            </summary>
        </member>
        <member name="P:Microsoft.VisualStudio.Utilities.PropertyCollection.PropertyList">
            <summary>
            Returns the property collection as a read-only collection.
            </summary>
            <value>The read-only collection.</value>
        </member>
        <member name="M:Microsoft.VisualStudio.Utilities.PropertyCollection.SetProperty(System.Object,System.Object)">
            <summary>
            Sets the property value for a given key.
            </summary>
            <param name="key">The key.</param>
            <param name="property">The property to set.</param>
            <exception cref="T:System.ArgumentNullException"><paramref name="key" /> is null.</exception>
        </member>
        <member name="T:Microsoft.VisualStudio.Utilities.SingletonBaseMetadataAttribute">
            <summary>
            A base class for attributes that can appear only once on a single component part.
            </summary>
        </member>
        <member name="T:Microsoft.VisualStudio.Utilities.TelemetryTaskDuration">
            <summary>
            Represents the duration of a specified measured task.
            </summary>
        </member>
        <member name="P:Microsoft.VisualStudio.Utilities.TelemetryTaskDuration.Duration">
            <summary>
            Gets the duration of the task.
            </summary>
        </member>
        <member name="M:Microsoft.VisualStudio.Utilities.TelemetryTaskDuration.CreateAndStart">
            <summary>
            Creates and starts a new measure.
            </summary>
            <returns>Returns a new instance of the <see cref="T:Microsoft.VisualStudio.Utilities.TelemetryTaskDuration" /> class.</returns>
        </member>
        <member name="M:Microsoft.VisualStudio.Utilities.TelemetryTaskDuration.Pause">
            <summary>
            Pause the measure.
            </summary>
        </member>
        <member name="M:Microsoft.VisualStudio.Utilities.TelemetryTaskDuration.Continue">
            <summary>
            Continue the measure if it was paused.
            </summary>
        </member>
        <member name="M:Microsoft.VisualStudio.Utilities.TelemetryTaskDuration.Dispose">
            <summary>
            Stops to measure the task and free the resources.
            </summary>
        </member>
        <member name="T:Microsoft.VisualStudio.Utilities.TypeConversionAttribute">
            <summary>
            Marks a class exported with a MEF <see cref="T:System.ComponentModel.Composition.ExportAttribute" /> as a conversion from one type to another.
            </summary>
        </member>
        <member name="M:Microsoft.VisualStudio.Utilities.TypeConversionAttribute.#ctor(System.Type,System.Type)">
            <summary>
            Creates a new instance of <see cref="T:Microsoft.VisualStudio.Utilities.TypeConversionAttribute" />.
            </summary>
            <param name="from">The <see cref="T:System.Type" /> being converted from.</param>
            <param name="to">The <see cref="T:System.Type" /> being converted to.</param>
        </member>
        <member name="P:Microsoft.VisualStudio.Utilities.TypeConversionAttribute.FromFullName">
            <summary>
            The name of the type being converted from.
            </summary>
        </member>
        <member name="P:Microsoft.VisualStudio.Utilities.TypeConversionAttribute.ToFullName">
            <summary>
            The name of the exact type being converted to.
            </summary>
        </member>
        <member name="T:Microsoft.VisualStudio.Utilities.ContentTypeAttribute">
            <summary>
            Declares an association between an extension part and a particular content type.
            </summary>
            <seealso cref="T:Microsoft.VisualStudio.Utilities.IContentType"></seealso>
            <seealso cref="T:Microsoft.VisualStudio.Utilities.IContentTypeRegistryService"></seealso>
            <seealso cref="T:Microsoft.VisualStudio.Utilities.ContentTypeDefinition"></seealso>
        </member>
        <member name="M:Microsoft.VisualStudio.Utilities.ContentTypeAttribute.#ctor(System.String)">
            <summary>
            Initializes a new instance of <see cref="T:Microsoft.VisualStudio.Utilities.ContentTypeAttribute" />.
            </summary>
            <param name="name">The content type name. 
            Content type names are case-insensitive.</param>
            <exception cref="T:System.ArgumentNullException"><paramref name="name" />is null or an empty string.</exception>
        </member>
        <member name="P:Microsoft.VisualStudio.Utilities.ContentTypeAttribute.ContentTypes">
            <summary>
            The content type name.
            </summary>
        </member>
        <member name="T:Microsoft.VisualStudio.Utilities.ContentTypeDefinition">
            <summary>
            Defines a content type.
            </summary>
            <remarks> 
            Because you cannot subclass this type, you can use the [Export] attribute with no type.
            </remarks>
            <example>
            <code>
            internal sealed class Components
            {
               [Export]
               [Name("Example")]            // required
               [BaseDefinition("text")]     // zero or more BaseDefinitions are allowed
               internal ContentTypeDefinition exampleDefinition;
               
               { other components }
            }
            </code>
            </example>
        </member>
        <member name="T:Microsoft.VisualStudio.Utilities.FileExtensionAttribute">
            <summary>
            Identifies a file extension.
            </summary>
        </member>
        <member name="M:Microsoft.VisualStudio.Utilities.FileExtensionAttribute.#ctor(System.String)">
            <summary>
            Constructs a new instance of the attribute.
            </summary>
            <param fileExtension="fileExtension">The file extension.</param>
            <exception cref="T:System.ArgumentNullException"><paramref name="fileExtension" /> is null or empty.</exception>
        </member>
        <member name="P:Microsoft.VisualStudio.Utilities.FileExtensionAttribute.FileExtension">
            <summary>
            Gets the file extension.
            </summary>
        </member>
        <member name="T:Microsoft.VisualStudio.Utilities.FileExtensionToContentTypeDefinition">
             <summary>
             Specifies a mapping between a content type and a file extension.
             </summary>
             <remarks>
             <para>
             Because you cannot subclass this type, you can use the [Export] attribute with no type.
             </para>
             <para>
             Compound extensions, such as '.abc.def' are supported via the <see cref="T:Microsoft.VisualStudio.Utilities.FileExtensionAttribute" />,
             however, if there is a mapping for a compound '.abc.def' and a simple extension 'def', the one that
             is longer wins.
             </para>
             </remarks>
             <example>
             <code>
             internal sealed class Components
             {
                [Export]
                [FileExtension(".abc")]           // Any file with the extension "abc" will get the "alphabet" content type.
                [ContentType("alphabet")]
                internal FileExtensionToContentTypeDefinition abcFileExtensionDefinition;
            
                [Export]
                [FileExtension(".abc.def")]       // Any file with the compound extension "abc.def" will get the "alphabet" content type.
                [ContentType("alphabet")]
                internal FileExtensionToContentTypeDefinition abcDefFileExtensionDefinition;
                
                [Export]
                [FileName("readme")]           // Any file named "readme" will get the "alphabet" content type.
                [ContentType("alphabet")]
                internal FileExtensionToContentTypeDefinition readmeFileNameDefinition;
                { other components }
             }
             </code>
             </example>
        </member>
        <member name="T:Microsoft.VisualStudio.Utilities.FileNameAttribute">
            <summary>
            Identifies a file name.
            </summary>
        </member>
        <member name="M:Microsoft.VisualStudio.Utilities.FileNameAttribute.#ctor(System.String)">
            <summary>
            Constructs a new instance of the attribute.
            </summary>
            <param name="fileName">The file extension.</param>
            <exception cref="T:System.ArgumentNullException"><paramref name="fileName" /> is null or empty.</exception>
        </member>
        <member name="P:Microsoft.VisualStudio.Utilities.FileNameAttribute.FileName">
            <summary>
            Gets the file name.
            </summary>
        </member>
        <member name="T:Microsoft.VisualStudio.Utilities.IContentType">
            <summary>
            The content type of an object.
            </summary>
            <remarks>All content types are identified by a unique name. 
            The <see cref="T:Microsoft.VisualStudio.Utilities.IContentTypeRegistryService"></see> can return an <see cref="T:Microsoft.VisualStudio.Utilities.IContentType"></see> object to allow clients to access additional information.</remarks>
        </member>
        <member name="P:Microsoft.VisualStudio.Utilities.IContentType.TypeName">
            <summary>
            The name of the content type.
            </summary>
            <value>This name must be unique, and must not be null.</value>
            <remarks>Comparisons performed on this name are case-insensitive.</remarks>
        </member>
        <member name="P:Microsoft.VisualStudio.Utilities.IContentType.DisplayName">
            <summary>
            The display name of the content type.
            </summary>
        </member>
        <member name="M:Microsoft.VisualStudio.Utilities.IContentType.IsOfType(System.String)">
            <summary>
            Returns <c>true</c> if this <see cref="T:Microsoft.VisualStudio.Utilities.IContentType"></see>
            equals or derives from the content type specified by <paramref name="type" />.
            </summary>
            <param name="type">The name of the base content type.</param>
            <returns><c>true</c> if this content type equals or derives from the one specified by <paramref name="type" />otherwise <c>false</c>.</returns>
        </member>
        <member name="P:Microsoft.VisualStudio.Utilities.IContentType.BaseTypes">
            <summary>
            The set of all content types from which the current <see cref="T:Microsoft.VisualStudio.Utilities.IContentType"></see> is derived.
            </summary>
            <value>This value is never null, though it may be the empty set.</value>
        </member>
        <member name="T:Microsoft.VisualStudio.Utilities.IContentTypeDefinition">
            <summary>
            Describes a content type that is being introduced using <see cref="T:Microsoft.VisualStudio.Utilities.IContentTypeDefinitionSource" />.
            </summary>
        </member>
        <member name="P:Microsoft.VisualStudio.Utilities.IContentTypeDefinition.Name">
            <summary>
            The case-insensitive name of the content type.
            </summary>
        </member>
        <member name="P:Microsoft.VisualStudio.Utilities.IContentTypeDefinition.BaseDefinitions">
            <summary>
            The case-insensitive names of the base types of the content type. May be of zero length.
            </summary>
        </member>
        <member name="T:Microsoft.VisualStudio.Utilities.IContentTypeDefinitionSource">
            <summary>
            Defines an alternate source for content type definitions that should be processed together
            with content types introduced statically using <see cref="T:Microsoft.VisualStudio.Utilities.ContentTypeDefinition" />. This is intended
            primarily for legacy VS content types.
            This is a MEF contract type. There is no associated metadata.
            </summary>
        </member>
        <member name="P:Microsoft.VisualStudio.Utilities.IContentTypeDefinitionSource.Definitions">
            <summary>
            Content type definitions.
            </summary>
        </member>
        <member name="T:Microsoft.VisualStudio.Utilities.IContentTypeMetadata">
            <summary>
            Represents MEF metadata view corresponding to the <see cref="T:Microsoft.VisualStudio.Utilities.ContentTypeAttribute" />s.
            </summary>
        </member>
        <member name="P:Microsoft.VisualStudio.Utilities.IContentTypeMetadata.ContentTypes">
            <summary>
            List of declared content types.
            </summary>
        </member>
        <member name="T:Microsoft.VisualStudio.Utilities.IContentTypeRegistryService">
            <summary>
            The service that maintains the collection of content types.
            </summary>
            <remarks>This is a MEF component part, and should be exported with the following attribute:
            [Export(typeof(IContentTypeRegistryService))]
            </remarks>
        </member>
        <member name="M:Microsoft.VisualStudio.Utilities.IContentTypeRegistryService.GetContentType(System.String)">
            <summary>
            Gets the <see cref="T:Microsoft.VisualStudio.Utilities.IContentType"></see> object with the specified <paramref name="typeName" />.
            </summary>
            <param name="typeName">The name of the content type. Name comparisons are case-insensitive.</param>
            <returns>The content type, or null if no content type is found.</returns>
        </member>
        <member name="M:Microsoft.VisualStudio.Utilities.IContentTypeRegistryService.AddContentType(System.String,System.Collections.Generic.IEnumerable{System.String})">
            <summary>
            Creates and adds a new content type.
            </summary>
            <param name="typeName">The name of the content type.</param>
            <param name="baseTypeNames">The list of content type names to be used as base content types. Optional.</param>
            <returns>The <see cref="T:Microsoft.VisualStudio.Utilities.IContentType"></see>.</returns>
            <exception cref="T:System.ArgumentException"><paramref name="typeName" /> is null or empty.</exception>
            <exception cref="T:System.InvalidOperationException"><paramref name="typeName" /> or one of the <paramref name="baseTypeNames" /> 
            is the name of <see cref="P:Microsoft.VisualStudio.Utilities.IContentTypeRegistryService.UnknownContentType" />, or the content type already exists, or one of the base types would
            introduce a cyclic base type relationship.</exception>
        </member>
        <member name="M:Microsoft.VisualStudio.Utilities.IContentTypeRegistryService.RemoveContentType(System.String)">
            <summary>
            Removes a content type.
            </summary>
            <remarks>The "unknown" content type cannot be removed. Any content type that is used for file extension 
            mapping or as a base for other content types cannot be removed.</remarks>
            <param name="typeName">The content type to be removed. </param>
            <exception cref="T:System.InvalidOperationException">The specified content type cannot be removed.</exception>
            <remarks>Has no effect if <paramref name="typeName" /> is not the name of a registered content type.</remarks>
        </member>
        <member name="P:Microsoft.VisualStudio.Utilities.IContentTypeRegistryService.UnknownContentType">
            <summary>
            Gets the "unknown" content type.
            </summary>
            <remarks>The "unknown" content type indicates that the content type cannot be determined.</remarks>
            <value>This value is never null.</value>
        </member>
        <member name="P:Microsoft.VisualStudio.Utilities.IContentTypeRegistryService.ContentTypes">
            <summary>Gets an enumeration of all content types, including the "unknown" content type.</summary>
        </member>
        <member name="M:Microsoft.VisualStudio.Utilities.IContentTypeRegistryService2.GetMimeType(Microsoft.VisualStudio.Utilities.IContentType)">
            <summary>
            Get the mime type associated with a content type.
            </summary>
            <remarks>Use the <see cref="T:Microsoft.VisualStudio.Utilities.MimeTypeAttribute" /> attribute on a <see cref="T:Microsoft.VisualStudio.Utilities.ContentTypeDefinition" /> to associate a mime type with a content type.</remarks>
        </member>
        <member name="M:Microsoft.VisualStudio.Utilities.IContentTypeRegistryService2.GetContentTypeForMimeType(System.String)">
            <summary>
            Get the content type associated with a mime type.
            </summary>
            <remarks>Use the <see cref="T:Microsoft.VisualStudio.Utilities.MimeTypeAttribute" /> attribute on a <see cref="T:Microsoft.VisualStudio.Utilities.ContentTypeDefinition" /> to associate a mime type with a content type.</remarks>
        </member>
        <member name="T:Microsoft.VisualStudio.Utilities.IFileExtensionRegistryService">
            <summary>
            The service that manages associations between file extensions and content types.
            </summary>
            <remarks>This is a MEF component part, and should be exported with the following attribute:
            [Export(typeof(IFileExtensionRegistryService))]
            </remarks>
        </member>
        <member name="M:Microsoft.VisualStudio.Utilities.IFileExtensionRegistryService.GetContentTypeForExtension(System.String)">
            <summary>
            Gets the content type associated with the given file extension.
            </summary>
            <param name="extension">The file extension.  It cannot be null, and it should not contain a period.</param>
            <returns>The <see cref="T:Microsoft.VisualStudio.Utilities.IContentType"></see> associated with this extension. If no association exists, it returns the "unknown" content type. It never returns null.</returns>
            <remarks>
            This method attempts to determine the <see cref="T:Microsoft.VisualStudio.Utilities.IContentType" /> of the file based on the information
            available. For best results, use <see cref="M:Microsoft.VisualStudio.Utilities.IFileToContentTypeService.GetContentTypeForFilePath(System.String)" />.
            </remarks>
        </member>
        <member name="M:Microsoft.VisualStudio.Utilities.IFileExtensionRegistryService.GetExtensionsForContentType(Microsoft.VisualStudio.Utilities.IContentType)">
            <summary>
            Gets the list of file extensions associated with the specified content type.
            </summary>
            <param name="contentType">The content type. It cannot be null.</param>
            <returns>The list of file extensions associated with the content type.</returns>
        </member>
        <member name="M:Microsoft.VisualStudio.Utilities.IFileExtensionRegistryService.AddFileExtension(System.String,Microsoft.VisualStudio.Utilities.IContentType)">
            <summary>
            Adds a new file extension to the registry.
            </summary>
            <param name="extension">The file extension (the period is optional).</param>
            <param name="contentType">The content type for the file extension.</param>
            <exception cref="T:System.InvalidOperationException"><see paramref="extension" /> is already present in the registry.</exception>
        </member>
        <member name="M:Microsoft.VisualStudio.Utilities.IFileExtensionRegistryService.RemoveFileExtension(System.String)">
            <summary>
            Removes the specified file extension from the registry.
            </summary>
            <remarks>If the specified extension does not exist, then the method does nothing.</remarks>
            <param name="extension">The file extension (the period is optional).</param>
        </member>
        <member name="T:Microsoft.VisualStudio.Utilities.IFileExtensionRegistryService2">
            <summary>
            The service that manages associations between file names, extensions, and content types.
            </summary>
            <remarks>This is a MEF component part, and should be exported with the following attribute:
            [Export(typeof(IFileExtensionRegistryService))]
            </remarks>
        </member>
        <member name="M:Microsoft.VisualStudio.Utilities.IFileExtensionRegistryService2.GetContentTypeForFileName(System.String)">
            <summary>
            Gets the content type associated with the given file name.
            </summary>
            <param name="name">The file name. It cannot be null.</param>
            <returns>The <see cref="T:Microsoft.VisualStudio.Utilities.IContentType" /> associated with this name. If no association exists, it returns the "unknown" content type. It never returns null.</returns>
            <remarks>
            This method attempts to determine the <see cref="T:Microsoft.VisualStudio.Utilities.IContentType" /> of the file based on the information
            available. For best results, use <see cref="M:Microsoft.VisualStudio.Utilities.IFileToContentTypeService.GetContentTypeForFilePath(System.String)" />.
            </remarks>
        </member>
        <member name="M:Microsoft.VisualStudio.Utilities.IFileExtensionRegistryService2.GetContentTypeForFileNameOrExtension(System.String)">
            <summary>
            Gets the content type associated with the given file name or its extension.
            </summary>
            <param name="name">The file name. It cannot be null.</param>
            <returns>The <see cref="T:Microsoft.VisualStudio.Utilities.IContentType" /> associated with this name. If no association exists, it returns the "unknown" content type. It never returns null.</returns>
            <remarks>
            This method attempts to determine the <see cref="T:Microsoft.VisualStudio.Utilities.IContentType" /> of the file based on the information
            available. For best results, use <see cref="M:Microsoft.VisualStudio.Utilities.IFileToContentTypeService.GetContentTypeForFilePath(System.String)" />.
            </remarks>
        </member>
        <member name="M:Microsoft.VisualStudio.Utilities.IFileExtensionRegistryService2.GetFileNamesForContentType(Microsoft.VisualStudio.Utilities.IContentType)">
            <summary>
            Gets the list of file names associated with the specified content type.
            </summary>
            <param name="contentType">The content type. It cannot be null.</param>
            <returns>The list of file names associated with the content type.</returns>
        </member>
        <member name="M:Microsoft.VisualStudio.Utilities.IFileExtensionRegistryService2.AddFileName(System.String,Microsoft.VisualStudio.Utilities.IContentType)">
            <summary>
            Adds a new file name to the registry.
            </summary>
            <param name="name">The file name (the period is optional).</param>
            <param name="contentType">The content type for the file name.</param>
            <exception cref="T:System.InvalidOperationException"><paramref name="name" /> is already present in the registry.</exception>
        </member>
        <member name="M:Microsoft.VisualStudio.Utilities.IFileExtensionRegistryService2.RemoveFileName(System.String)">
            <summary>
            Removes the specified file name from the registry.
            </summary>
            <remarks>If the specified name does not exist, then the method does nothing.</remarks>
            <param name="name">The file name (the period is optional).</param>
        </member>
        <member name="T:Microsoft.VisualStudio.Utilities.IFilePathToContentTypeProvider">
             <summary>
             MEF export to map full file names to a content type.
             </summary>
             <remarks>
             <para>Instances of this class should define the following MEF attributes.
             <code>
                [Export(typeof(IFilePathToContentTypeProvider)]      -- Required
                [Name("BamBam")]                                     -- Required
                [Order(After = "Fred", Before="Barney")]             -- Optional, can have more than one.
                [FileExtension(".abc")]                              -- Optional, but must have either a FileExtension or a FileName attribute. Can optionally be compound extension '.abc.def'.
                [FileName("George")]                                 -- Optional, but must have either a FileExtension or a FileName attribute
                [DeferCreation(OptionName = ...)]                    -- Optional, do not create this extension point unless OptionName is turned on.
             </code>
             You can use "*" as the FileExtension attribute to match any file extension.</para>
            
             <para>
             The <see cref="T:Microsoft.VisualStudio.Utilities.IFilePathToContentTypeProvider" /> will be called in order (based on the <see cref="T:Microsoft.VisualStudio.Utilities.OrderAttribute" />) if their
             <see cref="T:Microsoft.VisualStudio.Utilities.FileExtensionAttribute" /> matches the extension of the file in question (or is a "*") or the <see cref="T:Microsoft.VisualStudio.Utilities.FileNameAttribute" />
             matches the name of the file in question.
             </para>
             <para>
             Compound extensions, such as '.abc.def' are supported via the <see cref="T:Microsoft.VisualStudio.Utilities.FileExtensionAttribute" />,
             however, if there is a mapping for a compound '.abc.def' and a simple extension 'def', the one that
             is first via <see cref="T:Microsoft.VisualStudio.Utilities.OrderAttribute" /> wins.
             </para>
             </remarks>
        </member>
        <member name="M:Microsoft.VisualStudio.Utilities.IFilePathToContentTypeProvider.TryGetContentTypeForFilePath(System.String,Microsoft.VisualStudio.Utilities.IContentType@)">
            <summary>
            Gets the content-type for the given <paramref name="filePath" />.
            </summary>
            <param name="filePath">The path of the file to assign a content-type to.</param>
            <param name="contentType">The <see cref="T:Microsoft.VisualStudio.Utilities.IContentType" /> of the file path.</param>
            <returns><c>true</c> if content type is known for <paramref name="filePath" />.</returns>
        </member>
        <member name="T:Microsoft.VisualStudio.Utilities.IFileToContentTypeService">
            <summary>
            Service for mapping files to the appropriate <see cref="T:Microsoft.VisualStudio.Utilities.IContentType" /> for that file.
            </summary>
            <remarks>
            <para>
            Note that this interface duplicates the methods from <see cref="T:Microsoft.VisualStudio.Utilities.IFileExtensionRegistryService" /> and
            <see cref="T:Microsoft.VisualStudio.Utilities.IFileExtensionRegistryService2" />. The eventual goal is to deprecate the other interfaces
            and only use <see cref="T:Microsoft.VisualStudio.Utilities.IFileToContentTypeService" />.
            </para></remarks>
        </member>
        <member name="M:Microsoft.VisualStudio.Utilities.IFileToContentTypeService.GetContentTypeForFilePath(System.String)">
            <summary>
            Get the default <see cref="T:Microsoft.VisualStudio.Utilities.IContentType" /> for a file located at <paramref name="filePath" />.
            </summary>
            <param name="filePath">Name of the file in question.</param>
            <returns>Excpected content type or
            <see cref="P:Microsoft.VisualStudio.Utilities.IContentTypeRegistryService.UnknownContentType" /> if no content type is found.</returns>
            <remarks>If no <see cref="T:Microsoft.VisualStudio.Utilities.IContentType" /> is found using declared <see cref="T:Microsoft.VisualStudio.Utilities.IFilePathToContentTypeProvider" />
            assets, then the <see cref="M:Microsoft.VisualStudio.Utilities.IFileToContentTypeService.GetContentTypeForFileNameOrExtension(System.String)" /> is used.</remarks>
        </member>
        <member name="M:Microsoft.VisualStudio.Utilities.IFileToContentTypeService.GetContentTypeForFilePathOnly(System.String)">
            <summary>
            Get the default <see cref="T:Microsoft.VisualStudio.Utilities.IContentType" /> for a file located at <paramref name="filePath" />.
            </summary>
            <param name="filePath">Name of the file in question.</param>
            <returns>Excpected content type or
            <see cref="P:Microsoft.VisualStudio.Utilities.IContentTypeRegistryService.UnknownContentType" /> if no content type is found.</returns>
            <remarks>If no <see cref="T:Microsoft.VisualStudio.Utilities.IContentType" /> is found using declared <see cref="T:Microsoft.VisualStudio.Utilities.IFilePathToContentTypeProvider" />
            assets, then <see cref="P:Microsoft.VisualStudio.Utilities.IContentTypeRegistryService.UnknownContentType" /> is returned.</remarks>
        </member>
        <member name="M:Microsoft.VisualStudio.Utilities.IFileToContentTypeService.GetContentTypeForFileName(System.String)">
            <summary>
            Gets the content type associated with the given file name.
            </summary>
            <param name="name">The file name. It cannot be null.</param>
            <returns>The <see cref="T:Microsoft.VisualStudio.Utilities.IContentType"></see> associated with this name. If no association exists, it returns the "unknown" content type. It never returns null.</returns>
        </member>
        <member name="M:Microsoft.VisualStudio.Utilities.IFileToContentTypeService.GetContentTypeForFileNameOrExtension(System.String)">
            <summary>
            Gets the content type associated with the given file name or its extension.
            </summary>
            <param name="name">The file name. It cannot be null.</param>
            <returns>The <see cref="T:Microsoft.VisualStudio.Utilities.IContentType"></see> associated with this name. If no association exists, it returns the "unknown" content type. It never returns null.</returns>
        </member>
        <member name="M:Microsoft.VisualStudio.Utilities.IFileToContentTypeService.GetFileNamesForContentType(Microsoft.VisualStudio.Utilities.IContentType)">
            <summary>
            Gets the list of file names associated with the specified content type.
            </summary>
            <param name="contentType">The content type. It cannot be null.</param>
            <returns>The list of file names associated with the content type.</returns>
        </member>
        <member name="M:Microsoft.VisualStudio.Utilities.IFileToContentTypeService.AddFileName(System.String,Microsoft.VisualStudio.Utilities.IContentType)">
            <summary>
            Adds a new file name to the registry.
            </summary>
            <param name="name">The file name (the period is optional).</param>
            <param name="contentType">The content type for the file name.</param>
            <exception cref="T:System.InvalidOperationException"><paramref name="name" /> is already present in the registry.</exception>
        </member>
        <member name="M:Microsoft.VisualStudio.Utilities.IFileToContentTypeService.RemoveFileName(System.String)">
            <summary>
            Removes the specified file name from the registry.
            </summary>
            <remarks>If the specified name does not exist, then the method does nothing.</remarks>
            <param name="name">The file name (the period is optional).</param>
        </member>
        <member name="M:Microsoft.VisualStudio.Utilities.IFileToContentTypeService.GetContentTypeForExtension(System.String)">
            <summary>
            Gets the content type associated with the given file extension.
            </summary>
            <param name="extension">The file extension.  It cannot be null, and it should not contain a period.</param>
            <returns>The <see cref="T:Microsoft.VisualStudio.Utilities.IContentType"></see> associated with this extension. If no association exists, it returns the "unknown" content type. It never returns null.</returns>
        </member>
        <member name="M:Microsoft.VisualStudio.Utilities.IFileToContentTypeService.GetExtensionsForContentType(Microsoft.VisualStudio.Utilities.IContentType)">
            <summary>
            Gets the list of file extensions associated with the specified content type.
            </summary>
            <param name="contentType">The content type. It cannot be null.</param>
            <returns>The list of file extensions associated with the content type.</returns>
        </member>
        <member name="M:Microsoft.VisualStudio.Utilities.IFileToContentTypeService.AddFileExtension(System.String,Microsoft.VisualStudio.Utilities.IContentType)">
            <summary>
            Adds a new file extension to the registry.
            </summary>
            <param name="extension">The file extension (the period is optional).</param>
            <param name="contentType">The content type for the file extension.</param>
            <exception cref="T:System.InvalidOperationException"><paramref name="extension" /> is already present in the registry.</exception>
        </member>
        <member name="M:Microsoft.VisualStudio.Utilities.IFileToContentTypeService.RemoveFileExtension(System.String)">
            <summary>
            Removes the specified file extension from the registry.
            </summary>
            <remarks>If the specified extension does not exist, then the method does nothing.</remarks>
            <param name="extension">The file extension (the period is optional).</param>
        </member>
        <member name="T:Microsoft.VisualStudio.Utilities.INameAndReplacesMetadata">
            <summary>
            Represents MEF metadata view corresponding to the <see cref="T:Microsoft.VisualStudio.Utilities.NameAttribute" /> and ReplacesAttributes.
            </summary>
        </member>
        <member name="P:Microsoft.VisualStudio.Utilities.INameAndReplacesMetadata.Name">
            <summary>
            Declared name value.
            </summary>
        </member>
        <member name="P:Microsoft.VisualStudio.Utilities.INameAndReplacesMetadata.Replaces">
            <summary>
            Declared Replaces values.
            </summary>
        </member>
        <member name="P:Microsoft.VisualStudio.Utilities.INameAndReplacesMetadata.ReplacesOnlyIfCreated">
            <summary>
            Declared ReplacesOnlyIfCreated value
            </summary>
        </member>
        <member name="T:Microsoft.VisualStudio.Utilities.INamedContentTypeMetadata">
            <summary>
            Represents MEF metadata view combining <see cref="T:Microsoft.VisualStudio.Utilities.IContentTypeMetadata" /> and <see cref="T:Microsoft.VisualStudio.Utilities.INameAndReplacesMetadata" /> views.
            </summary>
        </member>
        <member name="T:Microsoft.VisualStudio.Utilities.MimeTypeAttribute">
            <summary>
            Declares an association between an extension part and a particular content type.
            </summary>
        </member>
        <member name="M:Microsoft.VisualStudio.Utilities.MimeTypeAttribute.#ctor(System.String)">
            <summary>
            Initializes a new instance of <see cref="T:Microsoft.VisualStudio.Utilities.MimeTypeAttribute" />.
            </summary>
            <param name="name">The Mime type to be associated with the content type.</param>
            <exception cref="T:System.ArgumentNullException"><paramref name="name" />is null or an empty string.</exception>
        </member>
        <member name="P:Microsoft.VisualStudio.Utilities.MimeTypeAttribute.MimeType">
            <summary>
            The MimeType for the content type definition
            </summary>
        </member>
        <member name="F:Microsoft.VisualStudio.Utilities.StandardContentTypeNames.Any">
            <summary>
            Base content type of all contents types except for <see cref="F:Microsoft.VisualStudio.Utilities.StandardContentTypeNames.Inert" />.
            </summary>
        </member>
        <member name="F:Microsoft.VisualStudio.Utilities.StandardContentTypeNames.Text">
            <summary>
            Base content type of any content type use for a document. Note that <see cref="F:Microsoft.VisualStudio.Utilities.StandardContentTypeNames.Projection" /> does not derive from <see cref="F:Microsoft.VisualStudio.Utilities.StandardContentTypeNames.Text" />.
            </summary>
        </member>
        <member name="F:Microsoft.VisualStudio.Utilities.StandardContentTypeNames.Code">
            <summary>
            Base content type of any document containing code. Derives from <see cref="F:Microsoft.VisualStudio.Utilities.StandardContentTypeNames.Text" />.
            </summary>
        </member>
        <member name="F:Microsoft.VisualStudio.Utilities.StandardContentTypeNames.Projection">
            <summary>
            Base content type for a projection of a document that contains a mix of distinct content types (e.g. a .aspx file containing
            html and embedded c#).
            </summary>
        </member>
        <member name="F:Microsoft.VisualStudio.Utilities.StandardContentTypeNames.Inert">
            <summary>
            A content type for which no associated artifacts are automatically created.
            </summary>
        </member>
        <member name="T:Microsoft.VisualStudio.Utilities.FeatureDefinition">
            <summary>
            Defines a feature which may be disabled using <see cref="T:Microsoft.VisualStudio.Utilities.IFeatureService" /> and grouped using <see cref="T:Microsoft.VisualStudio.Utilities.BaseDefinitionAttribute" />
            </summary>
            <remarks> 
            Because you cannot subclass this type, you can use the [Export] attribute with no type.
            </remarks>
            <example>
            <code>
            [Export]
            [Name(nameof(MyFeature))]   // required
            [BaseDefinition(PredefinedEditorFeatureNames.Popup)]   // zero or more BaseDefinitions are allowed
            public FeatureDefinition MyFeature;
            </code>
            </example>
        </member>
        <member name="T:Microsoft.VisualStudio.Utilities.FeatureUpdatedEventArgs">
            <summary>
            Notifies that a specific feature was updated and might have changed its state,
            without computing the state value.
            </summary>
        </member>
        <member name="P:Microsoft.VisualStudio.Utilities.FeatureUpdatedEventArgs.FeatureName">
            <summary>
            Name of feature that was updated.
            </summary>
        </member>
        <member name="M:Microsoft.VisualStudio.Utilities.FeatureUpdatedEventArgs.#ctor(System.String)">
            <summary>
            Creates an instance of <see cref="T:Microsoft.VisualStudio.Utilities.FeatureUpdatedEventArgs" />.
            </summary>
            <param name="featureName">Name of feature that was updated</param>
        </member>
        <member name="T:Microsoft.VisualStudio.Utilities.FeatureChangedEventArgs">
            <summary>
            Notifies that a specific feature changed state, and provides the new state value.
            </summary>
        </member>
        <member name="P:Microsoft.VisualStudio.Utilities.FeatureChangedEventArgs.FeatureName">
            <summary>
            Name of feature that was changed.
            </summary>
        </member>
        <member name="P:Microsoft.VisualStudio.Utilities.FeatureChangedEventArgs.IsEnabled">
            <summary>
            New value of the feature state.
            </summary>
        </member>
        <member name="M:Microsoft.VisualStudio.Utilities.FeatureChangedEventArgs.#ctor(System.String,System.Boolean)">
            <summary>
            Creates an instance of <see cref="T:Microsoft.VisualStudio.Utilities.FeatureChangedEventArgs" />.
            </summary>
            <param name="featureName">Name of feature that was changed</param>
            <param name="isEnabled">New value of the feature state</param>
        </member>
        <member name="T:Microsoft.VisualStudio.Utilities.IFeatureController">
            <summary>
            Keeps track of requests to disable a feature using <see cref="T:Microsoft.VisualStudio.Utilities.IFeatureService" />.
            Each <see cref="T:Microsoft.VisualStudio.Utilities.IFeatureController" /> may re-enable a feature it disabled,
            but may not re-enable a feature disabled by another <see cref="T:Microsoft.VisualStudio.Utilities.IFeatureController" />.
            </summary>
        </member>
        <member name="T:Microsoft.VisualStudio.Utilities.IFeatureCookie">
            <summary>
            Provides O(1) read only view on the state of the feature
            in the <see cref="T:Microsoft.VisualStudio.Utilities.IFeatureService" /> that created this <see cref="T:Microsoft.VisualStudio.Utilities.IFeatureCookie" />.
            Also exposes an event that provides notification when the state of the feature changes.
            </summary>
        </member>
        <member name="E:Microsoft.VisualStudio.Utilities.IFeatureCookie.StateChanged">
            <summary>
            Provides notification when <see cref="P:Microsoft.VisualStudio.Utilities.IFeatureCookie.IsEnabled" /> value changes.
            </summary>
        </member>
        <member name="P:Microsoft.VisualStudio.Utilities.IFeatureCookie.IsEnabled">
            <summary>
            Up to date state of the feature.
            </summary>
        </member>
        <member name="P:Microsoft.VisualStudio.Utilities.IFeatureCookie.FeatureName">
            <summary>
            Name of the tracked feature.
            </summary>
        </member>
        <member name="T:Microsoft.VisualStudio.Utilities.IFeatureDisableToken">
            <summary>
            Keeps track of the request to disable the feature.
            To restore the feature, 
            </summary>
        </member>
        <member name="T:Microsoft.VisualStudio.Utilities.IFeatureService">
             <summary>
             Service that keeps track of <see cref="T:Microsoft.VisualStudio.Utilities.IFeatureController" />'s requests to disable a feature in given scope.
             When multiple <see cref="T:Microsoft.VisualStudio.Utilities.IFeatureController" />s disable a feature and one <see cref="T:Microsoft.VisualStudio.Utilities.IFeatureController" />
             enables it back, it will not interfere with other disable requests, and feature will ultimately remain disabled.
            
             While this service does have a thread affinity, its implementation does not guarantee thread safety.
             It is advised to change feature state from UI thread, otherwise simultaneous changes may result in race conditions.
             </summary>
             <example>
             In an exported MEF part:
             <code>
             [Import]
             IFeatureServiceFactory FeatureServiceFactory;
            
             IFeatureService globalService = FeatureServiceFactory.GlobalFeatureService;
             IFeatureService localService = FeatureServiceFactory.GetOrCreate(scope); // scope is an IPropertyOwner
            
             // Also have a reference to <see cref="T:Microsoft.VisualStudio.Utilities.IFeatureController" />:
             IFeatureController MyFeatureController;
             // Interact with the <see cref="T:Microsoft.VisualStudio.Utilities.IFeatureService" />:
             globalService.Disable(PredefinedEditorFeatureNames.Popup, MyFeatureController);
             localService.IsEnabled(PredefinedEditorFeatureNames.Completion); // returns false, because Popup is a base definition of Completion and because global scope is a superset of local scope.
             </code>
             </example>
        </member>
        <member name="M:Microsoft.VisualStudio.Utilities.IFeatureService.IsEnabled(System.String)">
            <summary>
            Checks if feature is enabled. By default, every feature is enabled.
            </summary>
            <param name="featureName">Name of the feature</param>
            <returns>False if there are any disable requests. True otherwise.</returns>
        </member>
        <member name="M:Microsoft.VisualStudio.Utilities.IFeatureService.Disable(System.String,Microsoft.VisualStudio.Utilities.IFeatureController)">
            <summary>
            Disables a feature.
            </summary>
            <param name="featureName">Name of the feature to disable</param>
            <param name="controller">Object that uniquely identifies the caller.</param>
        </member>
        <member name="E:Microsoft.VisualStudio.Utilities.IFeatureService.StateUpdated">
            <summary>
            Provides a notification when this feature or its base feature was updated.
            We use FeatureUpdatedEventArgs and not FeatureChangedEventArgs
            because there are base features and disable requests from parent scopes that affect the factual state of given feature.
            We use this event to let the interested parties (<see cref="T:Microsoft.VisualStudio.Utilities.IFeatureCookie" />) recalculate the actual state of the feature.
            </summary>
        </member>
        <member name="M:Microsoft.VisualStudio.Utilities.IFeatureService.GetCookie(System.String)">
            <summary>
            Creates a new <see cref="T:Microsoft.VisualStudio.Utilities.IFeatureCookie" /> that provides O(1) access to the feature's value, in this service's scope.
            The <see cref="T:Microsoft.VisualStudio.Utilities.IFeatureCookie" /> is updated when the feature or its base is updated in this scope or in the global scope.
            </summary>
            <param name="featureName">Name of the feature</param>
            <returns>New instance of <see cref="T:Microsoft.VisualStudio.Utilities.IFeatureCookie" /></returns>
        </member>
        <member name="T:Microsoft.VisualStudio.Utilities.IFeatureServiceFactory">
             <summary>
             Service that provides <see cref="T:Microsoft.VisualStudio.Utilities.IFeatureService" />s used to track feature availability and to request feature to be disabled.
             Feature may be tracked by scope, using <see cref="M:Microsoft.VisualStudio.Utilities.IFeatureServiceFactory.GetOrCreate(Microsoft.VisualStudio.Utilities.IPropertyOwner)" /> and passing <see cref="T:Microsoft.VisualStudio.Utilities.IPropertyOwner" /> e.g. a text view.
             or throughout the application using <see cref="P:Microsoft.VisualStudio.Utilities.IFeatureServiceFactory.GlobalFeatureService" />.
             
             Features are implemented by exporting <see cref="T:Microsoft.VisualStudio.Utilities.FeatureDefinition" /> and grouped using <see cref="T:Microsoft.VisualStudio.Utilities.BaseDefinitionAttribute" />.
             Grouping allows alike features to be disabling at once.
             Grouping also relieves <see cref="T:Microsoft.VisualStudio.Utilities.IFeatureController" /> from updating its code when new feature of appropriate category is introduced.
             Standard editor feature names are available in <see cref="T:Microsoft.VisualStudio.Utilities.PredefinedEditorFeatureNames" />.
             </summary>
             <example>
             In an exported MEF part:
             <code>
             [Import]
             IFeatureServiceFactory FeatureServiceFactory;
            
             IFeatureService globalService = FeatureServiceFactory.GlobalFeatureService;
             IFeatureService localService = FeatureServiceFactory.GetOrCreate(scope); // scope is an IPropertyOwner
            
             // Also have a reference to <see cref="T:Microsoft.VisualStudio.Utilities.IFeatureController" />:
             IFeatureController MyFeatureController;
             // Interact with the <see cref="T:Microsoft.VisualStudio.Utilities.IFeatureService" />:
             globalService.Disable(PredefinedEditorFeatureNames.Popup, MyFeatureController);
             localService.IsEnabled(PredefinedEditorFeatureNames.Completion); // returns false, because Popup is a base definition of Completion and because global scope is a superset of local scope.
             </code>
             </example>
        </member>
        <member name="P:Microsoft.VisualStudio.Utilities.IFeatureServiceFactory.GlobalFeatureService">
            <summary>
            Gets the global <see cref="T:Microsoft.VisualStudio.Utilities.IFeatureService" />
            </summary>
        </member>
        <member name="M:Microsoft.VisualStudio.Utilities.IFeatureServiceFactory.GetOrCreate(Microsoft.VisualStudio.Utilities.IPropertyOwner)">
            <summary>
            Gets the <see cref="T:Microsoft.VisualStudio.Utilities.IFeatureService" /> for the specified scope.
            </summary>
            <param name="scope"></param>
            <returns></returns>
        </member>
        <member name="T:Microsoft.VisualStudio.Utilities.PredefinedEditorFeatureNames">
            <summary>
            Contains definitions for known <see cref="T:Microsoft.VisualStudio.Utilities.FeatureDefinition" />s and their groupings.
            </summary>
        </member>
        <member name="F:Microsoft.VisualStudio.Utilities.PredefinedEditorFeatureNames.Editor">
            <summary>
            Definition of group of features that make up the core editor.
            </summary>
        </member>
        <member name="F:Microsoft.VisualStudio.Utilities.PredefinedEditorFeatureNames.Popup">
            <summary>
            Definition of group of features that appear in a popup.
            </summary>
        </member>
        <member name="F:Microsoft.VisualStudio.Utilities.PredefinedEditorFeatureNames.InteractivePopup">
            <summary>
            Definition of group of features that appear in an interactive popup.
            Descends from <see cref="F:Microsoft.VisualStudio.Utilities.PredefinedEditorFeatureNames.Popup" />
            </summary>
        </member>
        <member name="F:Microsoft.VisualStudio.Utilities.PredefinedEditorFeatureNames.Completion">
            <summary>
            Definition of IntelliSense Completion.
            Descends from <see cref="F:Microsoft.VisualStudio.Utilities.PredefinedEditorFeatureNames.InteractivePopup" /> and <see cref="F:Microsoft.VisualStudio.Utilities.PredefinedEditorFeatureNames.Editor" />
            </summary>
        </member>
        <member name="F:Microsoft.VisualStudio.Utilities.PredefinedEditorFeatureNames.AsyncCompletion">
            <summary>
            Definition of IntelliSense Completion.
            Descends from <see cref="F:Microsoft.VisualStudio.Utilities.PredefinedEditorFeatureNames.InteractivePopup" /> and <see cref="F:Microsoft.VisualStudio.Utilities.PredefinedEditorFeatureNames.Editor" />
            </summary>
        </member>
        <member name="F:Microsoft.VisualStudio.Utilities.PredefinedEditorFeatureNames.CodeCleanup">
            <summary>
            Definition of Code Cleanup feature.
            </summary>
        </member>
        <member name="T:Microsoft.VisualStudio.Utilities.FrugalList`1">
            <summary>
            <para>
            This implementation is intended for lists that are usually empty or have a single element.
            The element type may be a struct or a class, but lists of structs are by far the most common
            in the editor. We store the head of the list in a local field and allocate an array for the tail of the
            list only if it the list has length greater than one. Thus singleton and empty lists require only
            a single object (not counting elements of the list), as compared to the BCL version of list, 
            which allocates two objects for a list with a single member.
            </para>
            <para>
            Do not use this implementation for lists that you know will have length greater than two; the
            platform list implementation will be more space efficient.
            </para>
            </summary>
            <typeparam name="T">The type of the list element.</typeparam>
        </member>
        <member name="M:Microsoft.VisualStudio.Utilities.ArrayBuilder`1.ToImmutable">
            <summary>
            Realizes the array.
            </summary>
        </member>
        <member name="M:Microsoft.VisualStudio.Utilities.ArrayBuilder`1.ToImmutableAndClear">
            <summary>
            Realizes the array and clears the collection.
            </summary>
        </member>
        <member name="M:Microsoft.VisualStudio.Utilities.ArrayBuilder`1.SetItem(System.Int32,`0)">
            <summary>
            Write <paramref name="value" /> to slot <paramref name="index" />. 
            Fills in unallocated slots preceding the <paramref name="index" />, if any.
            </summary>
        </member>
        <member name="M:Microsoft.VisualStudio.Utilities.ArrayBuilder`1.ToImmutableOrNull">
            <summary>
            Realizes the array.
            </summary>
        </member>
        <member name="M:Microsoft.VisualStudio.Utilities.ArrayBuilder`1.ToDowncastedImmutable``1">
            <summary>
            Realizes the array, downcasting each element to a derived type.
            </summary>
        </member>
        <member name="M:Microsoft.VisualStudio.Utilities.ArrayBuilder`1.ToImmutableAndFree">
            <summary>
            Realizes the array and disposes the builder in one operation.
            </summary>
        </member>
        <member name="T:Microsoft.VisualStudio.Utilities.ArrayBuilder`1.Enumerator">
            <summary>
            struct enumerator used in foreach.
            </summary>
        </member>
        <member name="T:Microsoft.VisualStudio.Utilities.ObjectPool`1">
            <summary>
            Generic implementation of object pooling pattern with predefined pool size limit. The main
            purpose is that limited number of frequently used objects can be kept in the pool for
            further recycling.
            
            Notes: 
            1) it is not the goal to keep all returned objects. Pool is not meant for storage. If there
               is no space in the pool, extra returned objects will be dropped.
            
            2) it is implied that if object was obtained from a pool, the caller will return it back in
               a relatively short time. Keeping checked out objects for long durations is ok, but 
               reduces usefulness of pooling. Just new up your own.
            
            Not returning objects to the pool in not detrimental to the pool's work, but is a bad practice. 
            Rationale: 
               If there is no intent for reusing the object, do not use pool - just use "new". 
            </summary>
        </member>
        <member name="T:Microsoft.VisualStudio.Utilities.ObjectPool`1.Factory">
            <remarks>
            Not using System.Func{T} because this file is linked into the (debugger) Formatter,
            which does not have that type (since it compiles against .NET 2.0).
            </remarks>
        </member>
        <member name="M:Microsoft.VisualStudio.Utilities.ObjectPool`1.Allocate">
            <summary>
            Produces an instance.
            </summary>
            <remarks>
            Search strategy is a simple linear probing which is chosen for it cache-friendliness.
            Note that Free will try to store recycled objects close to the start thus statistically 
            reducing how far we will typically search.
            </remarks>
        </member>
        <member name="M:Microsoft.VisualStudio.Utilities.ObjectPool`1.Free(`0)">
            <summary>
            Returns objects to the pool.
            </summary>
            <remarks>
            Search strategy is a simple linear probing which is chosen for it cache-friendliness.
            Note that Free will try to store recycled objects close to the start thus statistically 
            reducing how far we will typically search in Allocate.
            </remarks>
        </member>
        <member name="M:Microsoft.VisualStudio.Utilities.ObjectPool`1.ForgetTrackedObject(`0,`0)">
            <summary>
            Removes an object from leak tracking.  
            
            This is called when an object is returned to the pool.  It may also be explicitly 
            called if an object allocated from the pool is intentionally not being returned
            to the pool.  This can be of use with pooled arrays if the consumer wants to 
            return a larger array to the pool than was originally allocated.
            </summary>
        </member>
        <member name="T:Microsoft.VisualStudio.Utilities.PooledDelegates">
            <summary>
            Provides pooled delegate instances to help avoid closure allocations for delegates that require a state argument
            with APIs that do not provide appropriate overloads with state arguments.
            </summary>
        </member>
        <member name="M:Microsoft.VisualStudio.Utilities.PooledDelegates.GetPooledAction``1(System.Action{``0},``0,System.Action@)">
             <summary>
             Gets an <see cref="T:System.Action" /> delegate, which calls <paramref name="unboundAction" /> with the specified
             <paramref name="argument" />. The resulting <paramref name="boundAction" /> may be called any number of times
             until the returned <see cref="T:Microsoft.VisualStudio.Utilities.PooledDelegates.Releaser" /> is disposed.
             </summary>
             <example>
             <para>The following example shows the use of a capturing delegate for a callback action that requires an
             argument:</para>
            
             <code>
             int x = 3;
             RunWithActionCallback(() =&gt; this.DoSomething(x));
             </code>
            
             <para>The following example shows the use of a pooled delegate to avoid capturing allocations for the same
             callback action:</para>
            
             <code>
             int x = 3;
             using var _ = GetPooledAction(arg =&gt; arg.self.DoSomething(arg.x), (self: this, x), out Action action);
             RunWithActionCallback(action);
             </code>
             </example>
             <typeparam name="TArg">The type of argument to pass to <paramref name="unboundAction" />.</typeparam>
             <param name="unboundAction">The unbound action delegate.</param>
             <param name="argument">The argument to pass to the unbound action delegate.</param>
             <param name="boundAction">A delegate which calls <paramref name="unboundAction" /> with the specified
             <paramref name="argument" />.</param>
             <returns>A disposable <see cref="T:Microsoft.VisualStudio.Utilities.PooledDelegates.Releaser" /> which returns the object to the delegate pool.</returns>
        </member>
        <member name="M:Microsoft.VisualStudio.Utilities.PooledDelegates.GetPooledAction``2(System.Action{``0,``1},``1,System.Action{``0}@)">
             <summary>
             Gets an <see cref="T:System.Action`1" /> delegate, which calls <paramref name="unboundAction" /> with the specified
             <paramref name="argument" />. The resulting <paramref name="boundAction" /> may be called any number of times
             until the returned <see cref="T:Microsoft.VisualStudio.Utilities.PooledDelegates.Releaser" /> is disposed.
             </summary>
             <example>
             <para>The following example shows the use of a capturing delegate for a callback action that requires an
             argument:</para>
            
             <code>
             int x = 3;
             RunWithActionCallback(a =&gt; this.DoSomething(a, x));
             </code>
            
             <para>The following example shows the use of a pooled delegate to avoid capturing allocations for the same
             callback action:</para>
            
             <code>
             int x = 3;
             using var _ = GetPooledAction((a, arg) =&gt; arg.self.DoSomething(a, arg.x), (self: this, x), out Action&lt;int&gt; action);
             RunWithActionCallback(action);
             </code>
             </example>
             <typeparam name="T1">The type of the first parameter of the bound action.</typeparam>
             <typeparam name="TArg">The type of argument to pass to <paramref name="unboundAction" />.</typeparam>
             <param name="unboundAction">The unbound action delegate.</param>
             <param name="argument">The argument to pass to the unbound action delegate.</param>
             <param name="boundAction">A delegate which calls <paramref name="unboundAction" /> with the specified
             <paramref name="argument" />.</param>
             <returns>A disposable <see cref="T:Microsoft.VisualStudio.Utilities.PooledDelegates.Releaser" /> which returns the object to the delegate pool.</returns>
        </member>
        <member name="M:Microsoft.VisualStudio.Utilities.PooledDelegates.GetPooledAction``3(System.Action{``0,``1,``2},``2,System.Action{``0,``1}@)">
             <summary>
             Gets an <see cref="T:System.Action`2" /> delegate, which calls <paramref name="unboundAction" /> with the specified
             <paramref name="argument" />. The resulting <paramref name="boundAction" /> may be called any number of times
             until the returned <see cref="T:Microsoft.VisualStudio.Utilities.PooledDelegates.Releaser" /> is disposed.
             </summary>
             <example>
             <para>The following example shows the use of a capturing delegate for a callback action that requires an
             argument:</para>
            
             <code>
             int x = 3;
             RunWithActionCallback((a, b) =&gt; this.DoSomething(a, b, x));
             </code>
            
             <para>The following example shows the use of a pooled delegate to avoid capturing allocations for the same
             callback action:</para>
            
             <code>
             int x = 3;
             using var _ = GetPooledAction((a, b, arg) =&gt; arg.self.DoSomething(a, b, arg.x), (self: this, x), out Action&lt;int, int&gt; action);
             RunWithActionCallback(action);
             </code>
             </example>
             <typeparam name="T1">The type of the first parameter of the bound action.</typeparam>
             <typeparam name="T2">The type of the second parameter of the bound action.</typeparam>
             <typeparam name="TArg">The type of argument to pass to <paramref name="unboundAction" />.</typeparam>
             <param name="unboundAction">The unbound action delegate.</param>
             <param name="argument">The argument to pass to the unbound action delegate.</param>
             <param name="boundAction">A delegate which calls <paramref name="unboundAction" /> with the specified
             <paramref name="argument" />.</param>
             <returns>A disposable <see cref="T:Microsoft.VisualStudio.Utilities.PooledDelegates.Releaser" /> which returns the object to the delegate pool.</returns>
        </member>
        <member name="M:Microsoft.VisualStudio.Utilities.PooledDelegates.GetPooledAction``4(System.Action{``0,``1,``2,``3},``3,System.Action{``0,``1,``2}@)">
             <summary>
             Gets an <see cref="T:System.Action`3" /> delegate, which calls <paramref name="unboundAction" /> with the specified
             <paramref name="argument" />. The resulting <paramref name="boundAction" /> may be called any number of times
             until the returned <see cref="T:Microsoft.VisualStudio.Utilities.PooledDelegates.Releaser" /> is disposed.
             </summary>
             <example>
             <para>The following example shows the use of a capturing delegate for a callback action that requires an
             argument:</para>
            
             <code>
             int x = 3;
             RunWithActionCallback((a, b, c) =&gt; this.DoSomething(a, b, c, x));
             </code>
            
             <para>The following example shows the use of a pooled delegate to avoid capturing allocations for the same
             callback action:</para>
            
             <code>
             int x = 3;
             using var _ = GetPooledAction((a, b, c, arg) =&gt; arg.self.DoSomething(a, b, c, arg.x), (self: this, x), out Action&lt;int, int, int&gt; action);
             RunWithActionCallback(action);
             </code>
             </example>
             <typeparam name="T1">The type of the first parameter of the bound action.</typeparam>
             <typeparam name="T2">The type of the second parameter of the bound action.</typeparam>
             <typeparam name="T3">The type of the third parameter of the bound action.</typeparam>
             <typeparam name="TArg">The type of argument to pass to <paramref name="unboundAction" />.</typeparam>
             <param name="unboundAction">The unbound action delegate.</param>
             <param name="argument">The argument to pass to the unbound action delegate.</param>
             <param name="boundAction">A delegate which calls <paramref name="unboundAction" /> with the specified
             <paramref name="argument" />.</param>
             <returns>A disposable <see cref="T:Microsoft.VisualStudio.Utilities.PooledDelegates.Releaser" /> which returns the object to the delegate pool.</returns>
        </member>
        <member name="M:Microsoft.VisualStudio.Utilities.PooledDelegates.GetPooledFunction``2(System.Func{``0,``1},``0,System.Func{``1}@)">
             <summary>
             Gets a <see cref="T:System.Func`1" /> delegate, which calls <paramref name="unboundFunction" /> with the
             specified <paramref name="argument" />. The resulting <paramref name="boundFunction" /> may be called any
             number of times until the returned <see cref="T:Microsoft.VisualStudio.Utilities.PooledDelegates.Releaser" /> is disposed.
             </summary>
             <example>
             <para>The following example shows the use of a capturing delegate for a predicate that requires an
             argument:</para>
            
             <code>
             int x = 3;
             RunWithPredicate(() =&gt; this.IsSomething(x));
             </code>
            
             <para>The following example shows the use of a pooled delegate to avoid capturing allocations for the same
             predicate:</para>
            
             <code>
             int x = 3;
             using var _ = GetPooledFunction(arg =&gt; arg.self.IsSomething(arg.x), (self: this, x), out Func&lt;bool&gt; predicate);
             RunWithPredicate(predicate);
             </code>
             </example>
             <typeparam name="TArg">The type of argument to pass to <paramref name="unboundFunction" />.</typeparam>
             <typeparam name="TResult">The type of the return value of the function.</typeparam>
             <param name="unboundFunction">The unbound function delegate.</param>
             <param name="argument">The argument to pass to the unbound function delegate.</param>
             <param name="boundFunction">A delegate which calls <paramref name="unboundFunction" /> with the specified
             <paramref name="argument" />.</param>
             <returns>A disposable <see cref="T:Microsoft.VisualStudio.Utilities.PooledDelegates.Releaser" /> which returns the object to the delegate pool.</returns>
        </member>
        <member name="M:Microsoft.VisualStudio.Utilities.PooledDelegates.GetPooledFunction``3(System.Func{``0,``1,``2},``1,System.Func{``0,``2}@)">
             <summary>
             Gets a <see cref="T:System.Func`2" /> delegate, which calls <paramref name="unboundFunction" /> with the
             specified <paramref name="argument" />. The resulting <paramref name="boundFunction" /> may be called any
             number of times until the returned <see cref="T:Microsoft.VisualStudio.Utilities.PooledDelegates.Releaser" /> is disposed.
             </summary>
             <example>
             <para>The following example shows the use of a capturing delegate for a predicate that requires an
             argument:</para>
            
             <code>
             int x = 3;
             RunWithPredicate(a =&gt; this.IsSomething(a, x));
             </code>
            
             <para>The following example shows the use of a pooled delegate to avoid capturing allocations for the same
             predicate:</para>
            
             <code>
             int x = 3;
             using var _ = GetPooledFunction((a, arg) =&gt; arg.self.IsSomething(a, arg.x), (self: this, x), out Func&lt;int, bool&gt; predicate);
             RunWithPredicate(predicate);
             </code>
             </example>
             <typeparam name="T1">The type of the first parameter of the bound function.</typeparam>
             <typeparam name="TArg">The type of argument to pass to <paramref name="unboundFunction" />.</typeparam>
             <typeparam name="TResult">The type of the return value of the function.</typeparam>
             <param name="unboundFunction">The unbound function delegate.</param>
             <param name="argument">The argument to pass to the unbound function delegate.</param>
             <param name="boundFunction">A delegate which calls <paramref name="unboundFunction" /> with the specified
             <paramref name="argument" />.</param>
             <returns>A disposable <see cref="T:Microsoft.VisualStudio.Utilities.PooledDelegates.Releaser" /> which returns the object to the delegate pool.</returns>
        </member>
        <member name="M:Microsoft.VisualStudio.Utilities.PooledDelegates.GetPooledFunction``4(System.Func{``0,``1,``2,``3},``2,System.Func{``0,``1,``3}@)">
             <summary>
             Gets a <see cref="T:System.Func`3" /> delegate, which calls <paramref name="unboundFunction" /> with the
             specified <paramref name="argument" />. The resulting <paramref name="boundFunction" /> may be called any
             number of times until the returned <see cref="T:Microsoft.VisualStudio.Utilities.PooledDelegates.Releaser" /> is disposed.
             </summary>
             <example>
             <para>The following example shows the use of a capturing delegate for a predicate that requires an
             argument:</para>
            
             <code>
             int x = 3;
             RunWithPredicate((a, b) =&gt; this.IsSomething(a, b, x));
             </code>
            
             <para>The following example shows the use of a pooled delegate to avoid capturing allocations for the same
             predicate:</para>
            
             <code>
             int x = 3;
             using var _ = GetPooledFunction((a, b, arg) =&gt; arg.self.IsSomething(a, b, arg.x), (self: this, x), out Func&lt;int, int, bool&gt; predicate);
             RunWithPredicate(predicate);
             </code>
             </example>
             <typeparam name="T1">The type of the first parameter of the bound function.</typeparam>
             <typeparam name="T2">The type of the second parameter of the bound function.</typeparam>
             <typeparam name="TArg">The type of argument to pass to <paramref name="unboundFunction" />.</typeparam>
             <typeparam name="TResult">The type of the return value of the function.</typeparam>
             <param name="unboundFunction">The unbound function delegate.</param>
             <param name="argument">The argument to pass to the unbound function delegate.</param>
             <param name="boundFunction">A delegate which calls <paramref name="unboundFunction" /> with the specified
             <paramref name="argument" />.</param>
             <returns>A disposable <see cref="T:Microsoft.VisualStudio.Utilities.PooledDelegates.Releaser" /> which returns the object to the delegate pool.</returns>
        </member>
        <member name="M:Microsoft.VisualStudio.Utilities.PooledDelegates.GetPooledFunction``5(System.Func{``0,``1,``2,``3,``4},``3,System.Func{``0,``1,``2,``4}@)">
             <summary>
             Gets a <see cref="T:System.Func`4" /> delegate, which calls <paramref name="unboundFunction" /> with the
             specified <paramref name="argument" />. The resulting <paramref name="boundFunction" /> may be called any
             number of times until the returned <see cref="T:Microsoft.VisualStudio.Utilities.PooledDelegates.Releaser" /> is disposed.
             </summary>
             <example>
             <para>The following example shows the use of a capturing delegate for a predicate that requires an
             argument:</para>
            
             <code>
             int x = 3;
             RunWithPredicate((a, b, c) =&gt; this.IsSomething(a, b, c, x));
             </code>
            
             <para>The following example shows the use of a pooled delegate to avoid capturing allocations for the same
             predicate:</para>
            
             <code>
             int x = 3;
             using var _ = GetPooledFunction((a, b, c, arg) =&gt; arg.self.IsSomething(a, b, c, arg.x), (self: this, x), out Func&lt;int, int, int, bool&gt; predicate);
             RunWithPredicate(predicate);
             </code>
             </example>
             <typeparam name="T1">The type of the first parameter of the bound function.</typeparam>
             <typeparam name="T2">The type of the second parameter of the bound function.</typeparam>
             <typeparam name="T3">The type of the third parameter of the bound function.</typeparam>
             <typeparam name="TArg">The type of argument to pass to <paramref name="unboundFunction" />.</typeparam>
             <typeparam name="TResult">The type of the return value of the function.</typeparam>
             <param name="unboundFunction">The unbound function delegate.</param>
             <param name="argument">The argument to pass to the unbound function delegate.</param>
             <param name="boundFunction">A delegate which calls <paramref name="unboundFunction" /> with the specified
             <paramref name="argument" />.</param>
             <returns>A disposable <see cref="T:Microsoft.VisualStudio.Utilities.PooledDelegates.Releaser" /> which returns the object to the delegate pool.</returns>
        </member>
        <member name="T:Microsoft.VisualStudio.Utilities.PooledDelegates.Releaser">
             <summary>
             A releaser for a pooled delegate.
             </summary>
             <remarks>
             <para>This type is intended for use as the resource of a <c>using</c> statement. When used in this manner,
             <see cref="M:Microsoft.VisualStudio.Utilities.PooledDelegates.Releaser.Dispose" /> should not be called explicitly.</para>
            
             <para>If used without a <c>using</c> statement, calling <see cref="M:Microsoft.VisualStudio.Utilities.PooledDelegates.Releaser.Dispose" /> is optional. If the call is
             omitted, the object will not be returned to the pool. The behavior of this type if <see cref="M:Microsoft.VisualStudio.Utilities.PooledDelegates.Releaser.Dispose" /> is
             called multiple times is undefined.</para>
             </remarks>
        </member>
        <member name="M:Microsoft.VisualStudio.Utilities.PooledReadOnlyList`1.CalculateMaximumSmallObjectArrayLength">
            <summary>
            Calculates the maximum number of elements which can fit into an array that can be allocated in the small object heap.
            </summary>
        </member>
        <member name="T:Microsoft.VisualStudio.Utilities.PooledStringBuilder">
            <summary>
            The usage is:
                   var inst = PooledStringBuilder.GetInstance();
                   var sb = inst.builder;
                   ... Do Stuff...
                   ... sb.ToString() ...
                   inst.Free();
            </summary>
        </member>
        <member name="M:Microsoft.VisualStudio.Utilities.PooledStringBuilder.CreatePool(System.Int32)">
            <summary>
            If someone need to create a private pool
            </summary>
            <param name="size">The size of the pool.</param>
            <returns></returns>
        </member>
        <member name="T:Microsoft.VisualStudio.Utilities.CaseInsensitiveComparison">
            <summary>
            Case-insensitive operations (mostly comparison) on unicode strings.
            </summary>
        </member>
        <member name="M:Microsoft.VisualStudio.Utilities.CaseInsensitiveComparison.ToLower(System.Char)">
            <summary>
            ToLower implements the Unicode lowercase mapping
            as described in ftp://ftp.unicode.org/Public/UNIDATA/UnicodeData.txt.
            VB uses these mappings for case-insensitive comparison.
            </summary>
            <param name="c"></param>
            <returns>If <paramref name="c" /> is upper case, then this returns its Unicode lower case equivalent. Otherwise, <paramref name="c" /> is returned unmodified.</returns>
        </member>
        <member name="T:Microsoft.VisualStudio.Utilities.CaseInsensitiveComparison.OneToOneUnicodeComparer">
            <summary>
            This class seeks to perform the lowercase Unicode case mapping.
            </summary>
        </member>
        <member name="F:Microsoft.VisualStudio.Utilities.CaseInsensitiveComparison.s_comparer">
            <summary>
            Returns a StringComparer that compares strings according to Unicode rules for case-insensitive
            identifier comparison (lower-case mapping).
            </summary>
            <remarks>
            These are also the rules used for VB identifier comparison.
            </remarks>
        </member>
        <member name="P:Microsoft.VisualStudio.Utilities.CaseInsensitiveComparison.Comparer">
            <summary>
            Returns a StringComparer that compares strings according to Unicode rules for case-insensitive
            identifier comparison (lower-case mapping).
            </summary>
            <remarks>
            These are also the rules used for VB identifier comparison.
            </remarks>
        </member>
        <member name="M:Microsoft.VisualStudio.Utilities.CaseInsensitiveComparison.Equals(System.String,System.String)">
            <summary>
            Determines if two strings are equal according to Unicode rules for case-insensitive
            identifier comparison (lower-case mapping).
            </summary>
            <param name="left">First identifier to compare</param>
            <param name="right">Second identifier to compare</param>
            <returns>true if the identifiers should be considered the same.</returns>
            <remarks>
            These are also the rules used for VB identifier comparison.
            </remarks>
        </member>
        <member name="M:Microsoft.VisualStudio.Utilities.CaseInsensitiveComparison.Equals(System.ReadOnlySpan{System.Char},System.ReadOnlySpan{System.Char})">
            <summary>
            Determines if two strings are equal according to Unicode rules for case-insensitive
            identifier comparison (lower-case mapping).
            </summary>
            <param name="left">First identifier to compare</param>
            <param name="right">Second identifier to compare</param>
            <returns>true if the identifiers should be considered the same.</returns>
            <remarks>
            These are also the rules used for VB identifier comparison.
            </remarks>
        </member>
        <member name="M:Microsoft.VisualStudio.Utilities.CaseInsensitiveComparison.EndsWith(System.String,System.String)">
            <summary>
            Determines if the string 'value' end with string 'possibleEnd'.
            </summary>
            <param name="value"></param>
            <param name="possibleEnd"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.VisualStudio.Utilities.CaseInsensitiveComparison.StartsWith(System.String,System.String)">
            <summary>
            Determines if the string 'value' starts with string 'possibleStart'.
            </summary>
            <param name="value"></param>
            <param name="possibleStart"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.VisualStudio.Utilities.CaseInsensitiveComparison.Compare(System.String,System.String)">
            <summary>
            Compares two strings according to the Unicode rules for case-insensitive
            identifier comparison (lower-case mapping).
            </summary>
            <param name="left">First identifier to compare</param>
            <param name="right">Second identifier to compare</param>
            <returns>-1 if <paramref name="left" /> &lt; <paramref name="right" />, 1 if <paramref name="left" /> &gt; <paramref name="right" />, 0 if they are equal.</returns>
            <remarks>
            These are also the rules used for VB identifier comparison.
            </remarks>
        </member>
        <member name="M:Microsoft.VisualStudio.Utilities.CaseInsensitiveComparison.Compare(System.ReadOnlySpan{System.Char},System.ReadOnlySpan{System.Char})">
            <summary>
            Compares two strings according to the Unicode rules for case-insensitive
            identifier comparison (lower-case mapping).
            </summary>
            <param name="left">First identifier to compare</param>
            <param name="right">Second identifier to compare</param>
            <returns>-1 if <paramref name="left" /> &lt; <paramref name="right" />, 1 if <paramref name="left" /> &gt; <paramref name="right" />, 0 if they are equal.</returns>
            <remarks>
            These are also the rules used for VB identifier comparison.
            </remarks>
        </member>
        <member name="M:Microsoft.VisualStudio.Utilities.CaseInsensitiveComparison.GetHashCode(System.String)">
            <summary>
            Gets a case-insensitive hash code for Unicode identifiers.
            </summary>
            <param name="value">identifier to get the hash code for</param>
            <returns>The hash code for the given identifier</returns>
            <remarks>
            These are also the rules used for VB identifier comparison.
            </remarks>
        </member>
        <member name="M:Microsoft.VisualStudio.Utilities.CaseInsensitiveComparison.ToLower(System.Text.StringBuilder)">
            <summary>
            In-place convert string in StringBuilder to lower case per Unicode rules
            </summary>
            <param name="builder"></param>
        </member>
        <member name="T:Microsoft.VisualStudio.Utilities.FileNameUtilities">
            <summary>
            Implements a few file name utilities that are needed by the compiler.
            In general the compiler is not supposed to understand the format of the paths.
            In rare cases it needs to check if a string is a valid file name or change the extension 
            (embedded resources, netmodules, output name).
            The APIs are intentionally limited to cover just these rare cases. Do not add more APIs.
            </summary>
        </member>
        <member name="M:Microsoft.VisualStudio.Utilities.FileNameUtilities.IsFileName(System.String)">
            <summary>
            Returns true if the string represents an unqualified file name. 
            The name may contain any characters but directory and volume separators.
            </summary>
            <param name="path">Path.</param>
            <returns>
            True if <paramref name="path" /> is a simple file name, false if it is null or includes a directory specification.
            </returns>
        </member>
        <member name="M:Microsoft.VisualStudio.Utilities.FileNameUtilities.IndexOfExtension(System.String)">
            <summary>
            Returns the offset in <paramref name="path" /> where the dot that starts an extension is, or -1 if the path doesn't have an extension.
            </summary>
            <remarks>
            Returns 0 for path ".goo".
            Returns -1 for path "goo.".
            </remarks>
        </member>
        <member name="M:Microsoft.VisualStudio.Utilities.FileNameUtilities.GetExtension(System.String)">
            <summary>
            Returns an extension of the specified path string.
            </summary>
            <remarks>
            The same functionality as <see cref="M:System.IO.Path.GetExtension(System.String)" /> but doesn't throw an exception
            if there are invalid characters in the path.
            </remarks>
        </member>
        <member name="M:Microsoft.VisualStudio.Utilities.FileNameUtilities.RemoveExtension(System.String)">
            <summary>
            Removes extension from path.
            </summary>
            <remarks>
            Returns "goo" for path "goo.".
            Returns "goo.." for path "goo...".
            </remarks>
        </member>
        <member name="M:Microsoft.VisualStudio.Utilities.FileNameUtilities.ChangeExtension(System.String,System.String)">
            <summary>
            Returns path with the extension changed to <paramref name="extension" />.
            </summary>
            <returns>
            Equivalent of <see cref="M:System.IO.Path.ChangeExtension(System.String,System.String)" />
            
            If <paramref name="path" /> is null, returns null. 
            If path does not end with an extension, the new extension is appended to the path.
            If extension is null, equivalent to <see cref="M:Microsoft.VisualStudio.Utilities.FileNameUtilities.RemoveExtension(System.String)" />.
            </returns>
        </member>
        <member name="M:Microsoft.VisualStudio.Utilities.FileNameUtilities.IndexOfFileName(System.String)">
            <summary>
            Returns the position in given path where the file name starts.
            </summary>
            <returns>-1 if path is null.</returns>
        </member>
        <member name="M:Microsoft.VisualStudio.Utilities.FileNameUtilities.GetFileName(System.String,System.Boolean)">
            <summary>
            Get file name from path.
            </summary>
            <remarks>Unlike <see cref="M:System.IO.Path.GetFileName(System.String)" /> doesn't check for invalid path characters.</remarks>
        </member>
        <member name="M:Microsoft.VisualStudio.Utilities.Hash.Combine(System.Int32,System.Int32)">
            <summary>
            This is how VB Anonymous Types combine hash values for fields.
            </summary>
        </member>
        <member name="M:Microsoft.VisualStudio.Utilities.Hash.Combine``1(``0,System.Int32)">
            <summary>
            This is how VB Anonymous Types combine hash values for fields.
            PERF: Do not use with enum types because that involves multiple
            unnecessary boxing operations.  Unfortunately, we can't constrain
            T to "non-enum", so we'll use a more restrictive constraint.
            </summary>
        </member>
        <member name="F:Microsoft.VisualStudio.Utilities.Hash.FnvOffsetBias">
            <summary>
            The offset bias value used in the FNV-1a algorithm
            See http://en.wikipedia.org/wiki/Fowler%E2%80%93Noll%E2%80%93Vo_hash_function
            </summary>
        </member>
        <member name="F:Microsoft.VisualStudio.Utilities.Hash.FnvPrime">
            <summary>
            The generative factor used in the FNV-1a algorithm
            See http://en.wikipedia.org/wiki/Fowler%E2%80%93Noll%E2%80%93Vo_hash_function
            </summary>
        </member>
        <member name="M:Microsoft.VisualStudio.Utilities.Hash.GetFNVHashCode(System.Byte[])">
            <summary>
            Compute the FNV-1a hash of a sequence of bytes
            See http://en.wikipedia.org/wiki/Fowler%E2%80%93Noll%E2%80%93Vo_hash_function
            </summary>
            <param name="data">The sequence of bytes</param>
            <returns>The FNV-1a hash of <paramref name="data" /></returns>
        </member>
        <member name="M:Microsoft.VisualStudio.Utilities.Hash.GetFNVHashCode(System.ReadOnlySpan{System.Byte},System.Boolean@)">
            <summary>
            Compute the FNV-1a hash of a sequence of bytes and determines if the byte
            sequence is valid ASCII and hence the hash code matches a char sequence
            encoding the same text.
            See http://en.wikipedia.org/wiki/Fowler%E2%80%93Noll%E2%80%93Vo_hash_function
            </summary>
            <param name="data">The sequence of bytes that are likely to be ASCII text.</param>
            <param name="isAscii">True if the sequence contains only characters in the ASCII range.</param>
            <returns>The FNV-1a hash of <paramref name="data" /></returns>
        </member>
        <member name="M:Microsoft.VisualStudio.Utilities.Hash.GetFNVHashCode(System.Collections.Immutable.ImmutableArray{System.Byte})">
            <summary>
            Compute the FNV-1a hash of a sequence of bytes
            See http://en.wikipedia.org/wiki/Fowler%E2%80%93Noll%E2%80%93Vo_hash_function
            </summary>
            <param name="data">The sequence of bytes</param>
            <returns>The FNV-1a hash of <paramref name="data" /></returns>
        </member>
        <member name="M:Microsoft.VisualStudio.Utilities.Hash.GetFNVHashCode(System.ReadOnlySpan{System.Char})">
            <summary>
            Compute the hashcode of a sub-string using FNV-1a
            See http://en.wikipedia.org/wiki/Fowler%E2%80%93Noll%E2%80%93Vo_hash_function
            Note: FNV-1a was developed and tuned for 8-bit sequences. We're using it here
            for 16-bit Unicode chars on the understanding that the majority of chars will
            fit into 8-bits and, therefore, the algorithm will retain its desirable traits
            for generating hash codes.
            </summary>
        </member>
        <member name="M:Microsoft.VisualStudio.Utilities.Hash.GetFNVHashCode(System.String,System.Int32,System.Int32)">
            <summary>
            Compute the hashcode of a sub-string using FNV-1a
            See http://en.wikipedia.org/wiki/Fowler%E2%80%93Noll%E2%80%93Vo_hash_function
            Note: FNV-1a was developed and tuned for 8-bit sequences. We're using it here
            for 16-bit Unicode chars on the understanding that the majority of chars will
            fit into 8-bits and, therefore, the algorithm will retain its desirable traits
            for generating hash codes.
            </summary>
            <param name="text">The input string</param>
            <param name="start">The start index of the first character to hash</param>
            <param name="length">The number of characters, beginning with <paramref name="start" /> to hash</param>
            <returns>The FNV-1a hash code of the substring beginning at <paramref name="start" /> and ending after <paramref name="length" /> characters.</returns>
        </member>
        <member name="M:Microsoft.VisualStudio.Utilities.Hash.GetFNVHashCode(System.String,System.Int32)">
            <summary>
            Compute the hashcode of a sub-string using FNV-1a
            See http://en.wikipedia.org/wiki/Fowler%E2%80%93Noll%E2%80%93Vo_hash_function
            </summary>
            <param name="text">The input string</param>
            <param name="start">The start index of the first character to hash</param>
            <returns>The FNV-1a hash code of the substring beginning at <paramref name="start" /> and ending at the end of the string.</returns>
        </member>
        <member name="M:Microsoft.VisualStudio.Utilities.Hash.GetFNVHashCode(System.String)">
            <summary>
            Compute the hashcode of a string using FNV-1a
            See http://en.wikipedia.org/wiki/Fowler%E2%80%93Noll%E2%80%93Vo_hash_function
            </summary>
            <param name="text">The input string</param>
            <returns>The FNV-1a hash code of <paramref name="text" /></returns>
        </member>
        <member name="M:Microsoft.VisualStudio.Utilities.Hash.GetFNVHashCode(System.Text.StringBuilder)">
            <summary>
            Compute the hashcode of a string using FNV-1a
            See http://en.wikipedia.org/wiki/Fowler%E2%80%93Noll%E2%80%93Vo_hash_function
            </summary>
            <param name="text">The input string</param>
            <returns>The FNV-1a hash code of <paramref name="text" /></returns>
        </member>
        <member name="M:Microsoft.VisualStudio.Utilities.Hash.GetFNVHashCode(System.Char[],System.Int32,System.Int32)">
            <summary>
            Compute the hashcode of a sub string using FNV-1a
            See http://en.wikipedia.org/wiki/Fowler%E2%80%93Noll%E2%80%93Vo_hash_function
            </summary>
            <param name="text">The input string as a char array</param>
            <param name="start">The start index of the first character to hash</param>
            <param name="length">The number of characters, beginning with <paramref name="start" /> to hash</param>
            <returns>The FNV-1a hash code of the substring beginning at <paramref name="start" /> and ending after <paramref name="length" /> characters.</returns>
        </member>
        <member name="M:Microsoft.VisualStudio.Utilities.Hash.GetFNVHashCode(System.Char)">
            <summary>
            Compute the hashcode of a single character using the FNV-1a algorithm
            See http://en.wikipedia.org/wiki/Fowler%E2%80%93Noll%E2%80%93Vo_hash_function
            Note: In general, this isn't any more useful than "char.GetHashCode". However,
            it may be needed if you need to generate the same hash code as a string or
            substring with just a single character.
            </summary>
            <param name="ch">The character to hash</param>
            <returns>The FNV-1a hash code of the character.</returns>
        </member>
        <member name="M:Microsoft.VisualStudio.Utilities.Hash.CombineFNVHash(System.Int32,System.String)">
            <summary>
            Combine a string with an existing FNV-1a hash code
            See http://en.wikipedia.org/wiki/Fowler%E2%80%93Noll%E2%80%93Vo_hash_function
            </summary>
            <param name="hashCode">The accumulated hash code</param>
            <param name="text">The string to combine</param>
            <returns>The result of combining <paramref name="hashCode" /> with <paramref name="text" /> using the FNV-1a algorithm</returns>
        </member>
        <member name="M:Microsoft.VisualStudio.Utilities.Hash.CombineFNVHash(System.Int32,System.Char)">
            <summary>
            Combine a char with an existing FNV-1a hash code
            See http://en.wikipedia.org/wiki/Fowler%E2%80%93Noll%E2%80%93Vo_hash_function
            </summary>
            <param name="hashCode">The accumulated hash code</param>
            <param name="ch">The new character to combine</param>
            <returns>The result of combining <paramref name="hashCode" /> with <paramref name="ch" /> using the FNV-1a algorithm</returns>
        </member>
        <member name="M:Microsoft.VisualStudio.Utilities.Hash.CombineFNVHash(System.Int32,System.ReadOnlySpan{System.Char})">
            <summary>
            Combine a string with an existing FNV-1a hash code
            See http://en.wikipedia.org/wiki/Fowler%E2%80%93Noll%E2%80%93Vo_hash_function
            </summary>
            <param name="hashCode">The accumulated hash code</param>
            <param name="data">The string to combine</param>
            <returns>The result of combining <paramref name="hashCode" /> with <paramref name="data" /> using the FNV-1a algorithm</returns>
        </member>
        <member name="F:Microsoft.VisualStudio.Utilities.PathKind.Empty">
            <summary>
            Null or empty.
            </summary>
        </member>
        <member name="F:Microsoft.VisualStudio.Utilities.PathKind.Relative">
            <summary>
            "file"
            </summary>
        </member>
        <member name="F:Microsoft.VisualStudio.Utilities.PathKind.RelativeToCurrentDirectory">
            <summary>
            ".\file"
            </summary>
        </member>
        <member name="F:Microsoft.VisualStudio.Utilities.PathKind.RelativeToCurrentParent">
            <summary>
            "..\file"
            </summary>
        </member>
        <member name="F:Microsoft.VisualStudio.Utilities.PathKind.RelativeToCurrentRoot">
            <summary>
            "\dir\file"
            </summary>
        </member>
        <member name="F:Microsoft.VisualStudio.Utilities.PathKind.RelativeToDriveDirectory">
            <summary>
            "C:dir\file"
            </summary>
        </member>
        <member name="F:Microsoft.VisualStudio.Utilities.PathKind.Absolute">
            <summary>
            "C:\file" or "\\machine" (UNC).
            </summary>
        </member>
        <member name="M:Microsoft.VisualStudio.Utilities.PathUtilities.IsDirectorySeparator(System.Char)">
            <summary>
            True if the character is the platform directory separator character or the alternate directory separator.
            </summary>
        </member>
        <member name="M:Microsoft.VisualStudio.Utilities.PathUtilities.IsAnyDirectorySeparator(System.Char)">
            <summary>
            True if the character is any recognized directory separator character.
            </summary>
        </member>
        <member name="M:Microsoft.VisualStudio.Utilities.PathUtilities.TrimTrailingSeparators(System.String)">
            <summary>
            Removes trailing directory separator characters
            </summary>
            <remarks>
            This will trim the root directory separator:
            "C:\" maps to "C:", and "/" maps to ""
            </remarks>
        </member>
        <member name="M:Microsoft.VisualStudio.Utilities.PathUtilities.EnsureTrailingSeparator(System.String)">
            <summary>
            Ensures a trailing directory separator character
            </summary>
        </member>
        <member name="M:Microsoft.VisualStudio.Utilities.PathUtilities.GetDirectoryName(System.String)">
            <summary>
            Get directory name from path.
            </summary>
            <remarks>
            Unlike <see cref="M:System.IO.Path.GetDirectoryName(System.String)" /> it doesn't check for invalid path characters
            </remarks>
            <returns>Prefix of path that represents a directory</returns>
        </member>
        <member name="M:Microsoft.VisualStudio.Utilities.PathUtilities.GetPathRoot(System.String)">
            <summary>
            Gets the root part of the path.
            </summary>
        </member>
        <member name="M:Microsoft.VisualStudio.Utilities.PathUtilities.GetPathKind(System.String)">
            <summary>
            Gets the specific kind of relative or absolute path.
            </summary>
        </member>
        <member name="M:Microsoft.VisualStudio.Utilities.PathUtilities.IsAbsolute(System.String)">
            <summary>
            True if the path is an absolute path (rooted to drive or network share)
            </summary>
        </member>
        <member name="M:Microsoft.VisualStudio.Utilities.PathUtilities.IsDriveRootedAbsolutePath(System.String)">
            <summary>
            Returns true if given path is absolute and starts with a drive specification ("C:\").
            </summary>
        </member>
        <member name="M:Microsoft.VisualStudio.Utilities.PathUtilities.CombineAbsoluteAndRelativePaths(System.String,System.String)">
            <summary>
            Combines an absolute path with a relative.
            </summary>
            <param name="root">Absolute root path.</param>
            <param name="relativePath">Relative path.</param>
            <returns>
            An absolute combined path, or null if <paramref name="relativePath" /> is 
            absolute (e.g. "C:\abc", "\\machine\share\abc"), 
            relative to the current root (e.g. "\abc"), 
            or relative to a drive directory (e.g. "C:abc\def").
            </returns>
            <seealso cref="M:Microsoft.VisualStudio.Utilities.PathUtilities.CombinePossiblyRelativeAndRelativePaths(System.String,System.String)" />
        </member>
        <member name="M:Microsoft.VisualStudio.Utilities.PathUtilities.CombinePossiblyRelativeAndRelativePaths(System.String,System.String)">
            <summary>
            Combine two paths, the first of which may be absolute.
            </summary>
            <param name="root">First path: absolute, relative, or null.</param>
            <param name="relativePath">Second path: relative and non-null.</param>
            <returns>null, if <paramref name="root" /> is null; a combined path, otherwise.</returns>
            <seealso cref="M:Microsoft.VisualStudio.Utilities.PathUtilities.CombineAbsoluteAndRelativePaths(System.String,System.String)" />
        </member>
        <member name="M:Microsoft.VisualStudio.Utilities.PathUtilities.CombinePaths(System.String,System.String)">
            <summary>
            Combines paths with the same semantics as <see cref="M:System.IO.Path.Combine(System.String,System.String)" />
            but does not throw on null paths or paths with invalid characters.
            </summary>
            <param name="root">First path: absolute, relative, or null.</param>
            <param name="path">Second path: absolute, relative, or null.</param>
            <returns>
            The combined paths. If <paramref name="path" /> contains an absolute path, returns <paramref name="path" />.
            </returns>
            <remarks>
            Relative and absolute paths treated the same as <see cref="M:System.IO.Path.Combine(System.String,System.String)" />.
            </remarks>
        </member>
        <member name="M:Microsoft.VisualStudio.Utilities.PathUtilities.IsFilePath(System.String)">
            <summary>
            Determines whether an assembly reference is considered an assembly file path or an assembly name.
            used, for example, on values of /r and #r.
            </summary>
        </member>
        <member name="M:Microsoft.VisualStudio.Utilities.PathUtilities.ContainsPathComponent(System.String,System.String,System.Boolean)">
            <summary>
            Determines if "path" contains 'component' within itself.
            i.e. asking if the path "c:\goo\bar\baz" has component "bar" would return 'true'.
            On the other hand, if you had "c:\goo\bar1\baz" then it would not have "bar" as a
            component.
            
            A path contains a component if any file name or directory name in the path
            matches 'component'.  As such, if you had something like "\\goo" then that would
            not have "goo" as a component. That's because here "goo" is the server name portion
            of the UNC path, and not an actual directory or file name.
            </summary>
        </member>
        <member name="M:Microsoft.VisualStudio.Utilities.PathUtilities.GetRelativePath(System.String,System.String)">
            <summary>
            Gets a path relative to a directory.
            </summary>
        </member>
        <member name="M:Microsoft.VisualStudio.Utilities.PathUtilities.IsChildPath(System.String,System.String)">
            <summary>
            True if the child path is a child of the parent path.
            </summary>
        </member>
        <member name="M:Microsoft.VisualStudio.Utilities.PathUtilities.PathsEqual(System.String,System.String)">
            <summary>
            True if the two paths are the same.
            </summary>
        </member>
        <member name="M:Microsoft.VisualStudio.Utilities.PathUtilities.PathsEqual(System.String,System.String,System.Int32)">
            <summary>
            True if the two paths are the same.  (but only up to the specified length)
            </summary>
        </member>
        <member name="M:Microsoft.VisualStudio.Utilities.PathUtilities.IsValidFilePath(System.String)">
            <summary>
            Unfortunately, we cannot depend on Path.GetInvalidPathChars() or Path.GetInvalidFileNameChars()
            From MSDN: The array returned from this method is not guaranteed to contain the complete set of characters
            that are invalid in file and directory names. The full set of invalid characters can vary by file system.
            https://msdn.microsoft.com/en-us/library/system.io.path.getinvalidfilenamechars.aspx
            
            Additionally, Path.GetInvalidPathChars() doesn't include "?" or "*" which are invalid characters,
            and Path.GetInvalidFileNameChars() includes ":" and "\" which are valid characters.
            
            The more accurate way is to let the framework parse the path and throw on any errors.
            </summary>
        </member>
        <member name="M:Microsoft.VisualStudio.Utilities.PathUtilities.NormalizeWithForwardSlash(System.String)">
            <summary>
            If the current environment uses the '\' directory separator, replaces all uses of '\'
            in the given string with '/'. Otherwise, returns the string.
            </summary>
            <remarks>
            This method is equivalent to Microsoft.CodeAnalysis.BuildTasks.GenerateMSBuildEditorConfig.NormalizeWithForwardSlash
            Both methods should be kept in sync.
            </remarks>
        </member>
        <member name="T:Microsoft.VisualStudio.Utilities.PlatformInformation">
            <summary>
            This class provides simple properties for determining whether the current platform is Windows or Unix-based.
            We intentionally do not use System.Runtime.InteropServices.RuntimeInformation.IsOSPlatform(...) because
            it incorrectly reports 'true' for 'Windows' in desktop builds running on Unix-based platforms via Mono.
            </summary>
        </member>
        <member name="M:Microsoft.VisualStudio.Utilities.ProtocolConversions.TryGetUriFromFilePath(System.String,System.Uri@)">
            <summary>
            Converts an absolute local file path or an absolute URL string to <see cref="T:System.Uri" /> that can be passed to servers properly
            encoded to round trip local file path.
            </summary>
            <returns>false if the <paramref name="absolutePath" /> can't be represented as <see cref="T:System.Uri" /> (for example,
            UNC paths with invalid characters in server name), true otherwise.</returns>
        </member>
        <member name="M:Microsoft.VisualStudio.Utilities.ProtocolConversions.GetUriFromFilePath(System.String)">
            <summary>
            Converts an absolute local file path or an absolute URL string to <see cref="T:System.Uri" /> that can be passed to servers properly
            encoded to round trip local file path.
            </summary>
            <exception cref="T:System.UriFormatException">
            The <paramref name="absolutePath" /> can't be represented as <see cref="T:System.Uri" />.
            For example, UNC paths with invalid characters in server name.
            </exception>
        </member>
        <member name="T:Microsoft.VisualStudio.Text.Utilities.ILoggingServiceInternal">
            <summary>
            Allows code in VS-Platform to log events.
            </summary>
            <remarks>
            For example, the VS Provider of this inserts data points into the telemetry data stream.
            </remarks>
        </member>
        <member name="M:Microsoft.VisualStudio.Text.Utilities.ILoggingServiceInternal.PostEvent(System.String,System.Object[])">
            <summary>
            Post the event named <paramref name="key" /> to the telemetry stream. Additional properties can be appended as name/value pairs in <paramref name="namesAndProperties" />.
            </summary>
        </member>
        <member name="M:Microsoft.VisualStudio.Text.Utilities.ILoggingServiceInternal.PostDelay(System.String,System.TimeSpan,Microsoft.VisualStudio.Utilities.IContentType)">
            <summary>
            Post the delay from <paramref name="operation" /> to the telemetry stream.
            </summary>
        </member>
        <member name="M:Microsoft.VisualStudio.Text.Utilities.ILoggingServiceInternal.PostEvent(System.String,System.Collections.Generic.IReadOnlyList{System.Object})">
            <summary>
            Post the event named <paramref name="key" /> to the telemetry stream. Additional properties can be appended as name/value pairs in <paramref name="namesAndProperties" />.
            </summary>
        </member>
        <member name="M:Microsoft.VisualStudio.Text.Utilities.ILoggingServiceInternal.PostFault(System.String,System.String,System.Exception,System.String,System.Nullable{System.Boolean},System.Object[])">
            <summary>
            Creates and posts a FaultEvent.
            </summary>
            <param name="eventName">
            An event name following data model schema.
            It requires that event name is a unique, not null or empty string.
            It consists of 3 parts and must follows pattern [product]/[featureName]/[entityName]. FeatureName could be a one-level feature or feature hierarchy delimited by "/".
            For examples,
            vs/platform/opensolution;
            vs/platform/editor/lightbulb/fixerror;
            </param>
            <param name="description">Fault description</param>
            <param name="exceptionObject">Exception instance</param>
            <param name="additionalErrorInfo">Additional information to be added to Watson's ErrorInformation.txt file.</param>
            <param name="isIncludedInWatsonSample">
            Gets or sets a value indicating whether we sample this event locally. Affects Watson only.
            If false, will not send to Watson: only sends the telemetry event to AI and doesn't call callback.
            Changing this will force the event to send to Watson. Be careful because it can have big perf impact.
            If unchanged, it will be set according to the default sample rate.
            </param>
            <param name="correlations">TelemetryEventCorrelations which help correlate this fault to the scope it was executing within</param>
        </member>
        <member name="M:Microsoft.VisualStudio.Text.Utilities.ILoggingServiceInternal.AdjustCounter(System.String,System.String,System.Int32)">
            <summary>
            Adjust the counter associated with <paramref name="key" /> and <paramref name="name" /> by <paramref name="delta" />.
            </summary>
            <remarks>
            <para>Counters start at 0.</para>
            <para>No information is sent over the wire until the <see cref="M:Microsoft.VisualStudio.Text.Utilities.ILoggingServiceInternal.PostCounters" /> is called.</para>
            </remarks>
        </member>
        <member name="M:Microsoft.VisualStudio.Text.Utilities.ILoggingServiceInternal.PostCounters">
            <summary>
            Post all of the counters.
            </summary>
            <remarks>
            <para>The counters are logged as if PostEvent had been called for each key with a list counter names and values.</para>
            <para>The counters are cleared as a side-effect of this call.</para>
            </remarks>
        </member>
        <member name="M:Microsoft.VisualStudio.Text.Utilities.ILoggingServiceInternal.RecordEventData``1(System.Object,System.String,``0)">
            <summary>
            Record data for an event that is owned and posted independently by another component.
            </summary>
        </member>
        <member name="P:Microsoft.VisualStudio.Text.Utilities.ILoggingServiceInternal.IsInternalUser">
            <summary>
            Gets a value indicating whether the user is within the <c>*.microsoft.com</c> corporate network.
            To determine whether we can collect additional telemetry, use <see cref="P:Microsoft.VisualStudio.Text.Utilities.ILoggingServiceInternal.CanCollectPrivateInformation" />.
            </summary>
        </member>
        <member name="P:Microsoft.VisualStudio.Text.Utilities.ILoggingServiceInternal.CanCollectPrivateInformation">
            <summary>
            Gets a value indicating whether the user is an internal MSFT user and not located in EU.
            </summary>
        </member>
        <member name="T:Microsoft.VisualStudio.Text.Utilities.IPerformanceMarkerBlockProvider">
            <summary>
            Allows marking actions for performance logging.
            </summary>
            <remarks>
            For example, the VS editor adapters return MeasurementBlock instances
            that log ETW events.
            </remarks>
        </member>
        <member name="T:Microsoft.VisualStudio.Text.Utilities.TelemetryComplexProperty">
            <summary>
            Allows code in VS-Platform to use complex telemetry properties, which reduce boilerplate code.
            </summary>
        </member>
        <member name="T:Microsoft.VisualStudio.Text.Utilities.TelemetryEventType">
            <summary>
            Supported telemetry event types.
            </summary>
        </member>
        <member name="F:Microsoft.VisualStudio.Text.Utilities.TelemetryEventType.UserTask">
            <summary>
            User task event
            </summary>
        </member>
        <member name="F:Microsoft.VisualStudio.Text.Utilities.TelemetryEventType.Trace">
            <summary>
            Trace event
            </summary>
        </member>
        <member name="F:Microsoft.VisualStudio.Text.Utilities.TelemetryEventType.Operation">
            <summary>
            Operation event
            </summary>
        </member>
        <member name="F:Microsoft.VisualStudio.Text.Utilities.TelemetryEventType.Fault">
            <summary>
            Fault event
            </summary>
        </member>
        <member name="F:Microsoft.VisualStudio.Text.Utilities.TelemetryEventType.Asset">
            <summary>
            Asset event
            </summary>
        </member>
        <member name="T:Microsoft.VisualStudio.Text.Utilities.TelemetryResult">
            <summary>
            An enum to define the result from user task or operation.
            </summary>
        </member>
        <member name="F:Microsoft.VisualStudio.Text.Utilities.TelemetryResult.None">
            <summary>
            Used for unknown or unavailable result.
            </summary>
        </member>
        <member name="F:Microsoft.VisualStudio.Text.Utilities.TelemetryResult.Success">
            <summary>
            A result without any failure from product or user.
            </summary>
        </member>
        <member name="F:Microsoft.VisualStudio.Text.Utilities.TelemetryResult.Failure">
            <summary>
            A result to indicate the action/operation failed because of product issue (not user faults)
            Consider using FaultEvent to provide more details about the failure.
            </summary>
        </member>
        <member name="F:Microsoft.VisualStudio.Text.Utilities.TelemetryResult.UserFault">
            <summary>
            A result to indicate the action/operation failed because of user fault (e.g., invalid input).
            Consider using FaultEvent to provide more details.
            </summary>
        </member>
        <member name="F:Microsoft.VisualStudio.Text.Utilities.TelemetryResult.UserCancel">
            <summary>
            A result to indicate the action/operation is cancelled by user.
            </summary>
        </member>
        <member name="T:Microsoft.VisualStudio.Text.INonJoinableTaskTrackerInternal">
            <summary>
            Internal tracker for non-joinable tasks. Used to ensure that all pending tasks
            have completed on editor host shutdown.
            </summary>
            <remarks>Methods of this interface can be called on any thread.</remarks>
        </member>
        <member name="T:Microsoft.VisualStudio.Core.Imaging.ImageId">
            <summary>
            Unique identifier for Visual Studio image asset.
            </summary>
            <remarks>
            On Windows systems, <see cref="T:Microsoft.VisualStudio.Core.Imaging.ImageId" /> can be converted to and from
            various other image representations via the ImageIdExtensions extension methods.
            </remarks>
        </member>
        <member name="F:Microsoft.VisualStudio.Core.Imaging.ImageId.Guid">
            <summary>
            The <see cref="F:Microsoft.VisualStudio.Core.Imaging.ImageId.Guid" /> identifying the group to which this image belongs.
            </summary>
        </member>
        <member name="F:Microsoft.VisualStudio.Core.Imaging.ImageId.Id">
            <summary>
            The <see cref="T:System.Int32" /> identifying the particular image from the group that this id maps to.
            </summary>
        </member>
        <member name="M:Microsoft.VisualStudio.Core.Imaging.ImageId.#ctor(System.Guid,System.Int32)">
            <summary>
            Creates a new instance of ImageId.
            </summary>
            <param name="guid">The <see cref="F:Microsoft.VisualStudio.Core.Imaging.ImageId.Guid" /> identifying the group to which this image belongs.</param>
            <param name="id">The <see cref="T:System.Int32" /> identifying the particular image from the group that this id maps to.</param>
        </member>
    </members>
<Signature xmlns="http://www.w3.org/2000/09/xmldsig#"><SignedInfo><CanonicalizationMethod Algorithm="http://www.w3.org/TR/2001/REC-xml-c14n-20010315" /><SignatureMethod Algorithm="http://www.w3.org/2001/04/xmldsig-more#rsa-sha256" /><Reference URI=""><Transforms><Transform Algorithm="http://www.w3.org/2000/09/xmldsig#enveloped-signature" /><Transform Algorithm="http://www.w3.org/TR/2001/REC-xml-c14n-20010315" /></Transforms><DigestMethod Algorithm="http://www.w3.org/2001/04/xmlenc#sha256" /><DigestValue>nQAjZmBKhmgP6czggH70KKQOLGq/PSCvvz6C9ZIcfCQ=</DigestValue></Reference></SignedInfo><SignatureValue>Tuu7HVCYP+ZkTY6WxWjqDiWOq+kUKzZr/bmNEnaRGCpjaD4mxEXeqnOlIvIW8Jb6czjj64vHx+IbY2FAI4LIPFuVBoUbLSkSDYddFhYauXiZpHJysiawYIlnNJlSItVgzmwWijpSV962eQcThzaaUrWnwuMTXzIKJ27yLip8FnSl2zlt9kZ2elqkER4Y5vP9BdGOKnMkk324Pl4aOramElQ+vIRJ8V2gMT5FCyv31Iq/UuODk8sNvaYH9DbOi+7Uq5WoNb47M27faUdw1hU8kN2ODwVVIRtX9Izk5hK1vivmCVmKzLhU+eZ288Ihy/iNLkTFRr/fbeacaBZExM7pBA==</SignatureValue><KeyInfo><KeyValue><RSAKeyValue><Modulus>zkvLNa2un9GBrYNDoRGkGv7d0PqtTBB4ViYakFbjuWpmF0KcvDAzzaCWJPhVgIXjz+S8cHEoHuWnp/n+UOljT3ehA8Rs6Lb1aTYub3tB/e0txewv2sQ3yscjYdtTBtFvEm9L8Yv76K3Cxzi/Yvrdg+sr7w8y5RHn1Am0Ff8xggY1xpWCXFI+kQM18njQDcUqSlwBnexYfqHBhzz6YXA/S0EziYBu2O2mM7R6gSyYkEOHgIGTVOGnOvvC5xBgC4KNcnQuQSRLiUI2CmzU8vefR6ykruyzt1rNMPI8OqWHQtSDKXU5JNqbk4GNjwzcwbSzOHrxuxWHq91l/vLdVDGDUw==</Modulus><Exponent>AQAB</Exponent></RSAKeyValue></KeyValue><X509Data><X509Certificate>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</X509Certificate><X509Certificate>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</X509Certificate><X509Certificate>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</X509Certificate></X509Data></KeyInfo><Object Id="ts-countersig"><X509Data><X509Certificate>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</X509Certificate><X509Certificate>MIIHcTCCBVmgAwIBAgITMwAAABXF52ueAptJmQAAAAAAFTANBgkqhkiG9w0BAQsFADCBiDELMAkGA1UEBhMCVVMxEzARBgNVBAgTCldhc2hpbmd0b24xEDAOBgNVBAcTB1JlZG1vbmQxHjAcBgNVBAoTFU1pY3Jvc29mdCBDb3Jwb3JhdGlvbjEyMDAGA1UEAxMpTWljcm9zb2Z0IFJvb3QgQ2VydGlmaWNhdGUgQXV0aG9yaXR5IDIwMTAwHhcNMjEwOTMwMTgyMjI1WhcNMzAwOTMwMTgzMjI1WjB8MQswCQYDVQQGEwJVUzETMBEGA1UECBMKV2FzaGluZ3RvbjEQMA4GA1UEBxMHUmVkbW9uZDEeMBwGA1UEChMVTWljcm9zb2Z0IENvcnBvcmF0aW9uMSYwJAYDVQQDEx1NaWNyb3NvZnQgVGltZS1TdGFtcCBQQ0EgMjAxMDCCAiIwDQYJKoZIhvcNAQEBBQADggIPADCCAgoCggIBAOThpkzntHIhC3miy9ckeb0O1YLT/e6cBwfSqWxOdcjKNVf2AX9sSuDivbk+F2Az/1xPx2b3lVNxWuJ+Slr+uDZnhUYjDLWNE893MsAQGOhgfWpSg0S3po5GawcU88V29YZQ3MFEyHFcUTE3oAo4bo3t1w/YJlN8OWECesSq/XJprx2rrPY2vjUmZNqYO7oaezOtgFt+jBAcnVL+tuhiJdxqD89d9P6OU8/W7IVWTe/dvI2k45GPsjksUZzpcGkNyjYtcI4xyDUoveO0hyTD4MmPfrVUj9z6BVWYbWg7mka97aSueik3rMvrg0XnRm7KMtXAhjBcTyziYrLNueKNiOSWrAFKu75xqRdbZ2De+JKRHh09/SDPc31BmkZ1zcRfNN0Sidb9pSB9fvzZnkXftnIv231fgLrbqn427DZM9ituqBJR6L8FA6PRc6ZNN3SUHDSCD/AQ8rdHGO2n6Jl8P0zbr17C89XYcz1DTsEzOUyOArxCaC4Q6oRRRuLRvWoYWmEBc8pnol7XKHYC4jMYctenIPDC+hIK12NvDMk2ZItboKaDIV1fMHSRlJTYuVD5C4lh8zYGNRiER9vcG9H9stQcxWv2XFJRXRLbJbqvUAV6bMURHXLvjflSxIUXk8A8FdsaN8cIFRg/eKtFtvUeh17aj54WcmnGrnu3tz5q4i6tAgMBAAGjggHdMIIB2TASBgkrBgEEAYI3FQEEBQIDAQABMCMGCSsGAQQBgjcVAgQWBBQqp1L+ZMSavoKRPEY1Kc8Q/y8E7jAdBgNVHQ4EFgQUn6cVXQBeYl2D9OXSZacbUzUZ6XIwXAYDVR0gBFUwUzBRBgwrBgEEAYI3TIN9AQEwQTA/BggrBgEFBQcCARYzaHR0cDovL3d3dy5taWNyb3NvZnQuY29tL3BraW9wcy9Eb2NzL1JlcG9zaXRvcnkuaHRtMBMGA1UdJQQMMAoGCCsGAQUFBwMIMBkGCSsGAQQBgjcUAgQMHgoAUwB1AGIAQwBBMAsGA1UdDwQEAwIBhjAPBgNVHRMBAf8EBTADAQH/MB8GA1UdIwQYMBaAFNX2VsuP6KJcYmjRPZSQW9fOmhjEMFYGA1UdHwRPME0wS6BJoEeGRWh0dHA6Ly9jcmwubWljcm9zb2Z0LmNvbS9wa2kvY3JsL3Byb2R1Y3RzL01pY1Jvb0NlckF1dF8yMDEwLTA2LTIzLmNybDBaBggrBgEFBQcBAQROMEwwSgYIKwYBBQUHMAKGPmh0dHA6Ly93d3cubWljcm9zb2Z0LmNvbS9wa2kvY2VydHMvTWljUm9vQ2VyQXV0XzIwMTAtMDYtMjMuY3J0MA0GCSqGSIb3DQEBCwUAA4ICAQCdVX38Kq3hLB9nATEkW+Geckv8qW/qXBS2Pk5HZHixBpOXPTEztTnXwnE2P9pkbHzQdTltuw8x5MKP+2zRoZQYIu7pZmc6U03dmLq2HnjYNi6cqYJWAAOwBb6J6Gngugnue99qb74py27YP0h1AdkY3m2CDPVtI1TkeFN1JFe53Z/zjj3G82jfZfakVqr3lbYoVSfQJL1AoL8ZthISEV09J+BAljis9/kpicO8F7BUhUKz/AyeixmJ5/ALaoHCgRlCGVJ1ijbCHcNhcy4sa3tuPywJeBTpkbKpW99Jo3QMvOyRgNI95ko+ZjtPu4b6MhrZlvSP9pEB9s7GdP32THJvEKt1MMU0sHrYUP4KWN1APMdUbZ1jdEgssU5HLcEUBHG/ZPkkvnNtyo4JvbMBV0lUZNlz138eW0QBjloZkWsNn6Qo3GcZKCS6OEuabvshVGtqRRFHqfG3rsjoiV5PndLQTHa1V1QJsWkBRH58oWFsc/4Ku+xBZj1p/cvBQUl+fpO+y/g75LcVv7TOPqUxUYS8vwLBgqJ7Fx0ViY1w/ue10CgaiQuPNtq6TPmb/wrpNPgkNWcr4A245oyZ1uEi6vAnQj0llOZ0dFtq0Z4+7X6gMTN9vMvpe784cETRkPHIqzqKOghif9lwY1NNje6CbaUFEMFxBmoQtB1VM1izoXBm8g==</X509Certificate></X509Data><CounterSignature ts-format="cms-timestamp-message" xmlns="http://schemas.microsoft.com/xmldsig/timestamp/2003">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</CounterSignature></Object></Signature></doc>
